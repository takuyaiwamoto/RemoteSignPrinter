<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' wss://realtime-sign-server-1.onrender.com ws://localhost:* wss://localhost:*; img-src 'self' data: blob:; media-src 'self';">
  <title>送信側2.9-fixed</title>
  <style>
    /* タッチデバイスでのズーム防止 */
    * {
      touch-action: manipulation; /* ダブルタップズーム無効 */
    }
    
    html {
      -ms-touch-action: manipulation;
      touch-action: manipulation;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
    }
    
    body {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    canvas {
      touch-action: none !important; /* キャンバスでのピンチズーム完全無効 */
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      /* ペン入力専用の追加対策 */
      pointer-events: auto;
      -ms-touch-action: none;
      -webkit-user-drag: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    /* クラシックスタイル（デフォルト） */
    body.classic .main-container {
      display: flex;
      gap: 10px;
    }
    body.classic .canvas-container {
      flex: 1;
    }
    body.classic .color-panel {
      display: none; /* 新しいレイアウトで置き換えのため非表示 */
    }
    body.classic .color-panel h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
    }
    body.classic .thickness-panel {
      display: none; /* 新しいレイアウトで置き換えのため非表示 */
    }
    body.classic .thickness-panel h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
    }
    body.classic canvas {
      border: 1px solid black;
      display: block;
      margin-bottom: 10px;
      max-width: 100%;
      width: 283px; /* 背景画像と同じサイズに固定 */
      height: 420px;
      aspect-ratio: 283 / 420; /* 背景画像の比率に修正 */
    }
    body.classic button {
      margin-right: 5px;
      margin-bottom: 5px;
    }
    body.classic .button-group {
      margin-bottom: 10px;
    }
    body.classic .button-group label {
      font-weight: bold;
      margin-right: 10px;
    }
    
    /* モダンスタイル */
    body.modern {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }
    
    body.modern .main-container {
      position: relative;
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(10px);
      display: flex;
      gap: 10px;
    }
    
    body.modern .canvas-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    body.modern .main-controls {
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 80px 0 15px 0; /* 上マージンを大幅に増加 */
      position: relative;
      z-index: 1000; /* 背景画像より前面に */
    }
    
    body.modern .pen-controls {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 30px;
      margin: 15px 0;
    }
    
    body.modern .pen-colors {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    body.modern .pen-thickness {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    body.modern .background-controls {
      width: 100%;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 15px 0;
    }
    
    body.modern .color-panel {
      display: none; /* 新しいレイアウトで置き換えのため非表示 */
    }
    
    body.modern .color-panel h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #2d3748;
      text-align: center;
    }
    
    body.modern .thickness-panel {
      display: none; /* 新しいレイアウトで置き換えのため非表示 */
    }
    
    body.modern .thickness-panel h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #2d3748;
      text-align: center;
    }
    
    body.modern canvas {
      border: none;
      border-radius: 15px;
      display: block;
      margin: 0 auto 20px auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      background: white;
      max-width: 100%;
      width: 100%; /* より大きく表示 */
      height: auto;
      aspect-ratio: 859 / 607; /* 元のアスペクト比を固定 */
    }
    
    body.modern button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 10px 20px;
      margin: 5px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    body.modern button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
    }
    
    body.modern button:active {
      transform: translateY(0);
    }
    
    body.modern .button-group {
      background: rgba(255, 255, 255, 0.7);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    body.modern .button-group label {
      font-weight: 700;
      margin-right: 15px;
      color: #2d3748;
      font-size: 16px;
    }
    
    body.modern h1 {
      text-align: center;
      color: #2d3748;
      font-size: 2.5rem;
      margin-bottom: 30px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 800;
    }
    body.modern #countdown {
      font-size: 32px;
      background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-top: 20px;
      text-align: center;
      font-weight: 800;
    }
    
    body.classic #countdown {
      font-size: 24px;
      color: red;
      margin-top: 10px;
    }
    
    body.modern .selected {
      background: linear-gradient(135deg, #48bb78, #38a169) !important;
      color: white;
      box-shadow: 0 6px 20px rgba(72, 187, 120, 0.5) !important;
    }
    
    body.classic .selected {
      background-color: #4CAF50;
      color: white;
    }
    
    /* テーマ切り替えボタン */
    #themeToggle {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      transition: all 0.3s ease;
    }
    
    #themeToggle:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    
    /* モダンな開発ツールパネル */
    body.modern #devToolsPanel {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 20px;
      padding: 25px;
      margin-top: 20px;
      border: 2px solid rgba(102, 126, 234, 0.2);
      backdrop-filter: blur(10px);
    }
    
    body.modern #devToolsPanel h3 {
      color: #2d3748;
      margin-bottom: 20px;
      font-size: 1.5rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    body.modern input[type="checkbox"] {
      width: 20px;
      height: 20px;
      margin-right: 10px;
      accent-color: #667eea;
    }
    body.modern .color-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.8);
      margin: 0;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    
    body.modern .color-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }
    
    body.modern .color-btn.selected {
      border: 4px solid #ffffff;
      box-shadow: 0 0 0 3px #2d3748, 0 0 20px 5px rgba(45, 55, 72, 0.6), 0 8px 30px rgba(0, 0, 0, 0.4);
      transform: scale(1.15);
      background: attr(style) !important;
    }
    
    /* 各色ボタンの選択時の背景色を個別に指定 */
    body.modern .color-btn.selected[style*="background: black"] {
      background: black !important;
    }
    
    body.modern .color-btn.selected[style*="background: red"] {
      background: red !important;
    }
    
    body.modern .color-btn.selected[style*="background: blue"] {
      background: blue !important;
    }
    
    body.modern .color-btn.selected[style*="background: green"] {
      background: green !important;
    }
    
    /* ペンの太さボタンのスタイル */
    body.modern .thickness-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.8);
      margin: 0;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      background: rgba(255, 255, 255, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    body.modern .thickness-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }
    
    body.modern .thickness-btn.selected {
      border: 4px solid #ffffff;
      box-shadow: 0 0 0 3px #2d3748, 0 0 20px 5px rgba(45, 55, 72, 0.6), 0 8px 30px rgba(0, 0, 0, 0.4);
      transform: scale(1.15);
      background: rgba(255, 255, 255, 1);
    }
    
    body.classic .color-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 2px solid #ccc;
      margin: 0;
      cursor: pointer;
    }
    
    body.classic .color-btn.selected {
      border: 3px solid #ffffff;
      box-shadow: 0 0 0 2px #333, 0 0 15px 3px rgba(51, 51, 51, 0.7), 0 4px 20px rgba(0,0,0,0.6);
      transform: scale(1.1);
    }
    
    /* クラシック - 各色ボタンの選択時の背景色を個別に指定 */
    body.classic .color-btn.selected[style*="background: black"] {
      background: black !important;
    }
    
    body.classic .color-btn.selected[style*="background: red"] {
      background: red !important;
    }
    
    body.classic .color-btn.selected[style*="background: blue"] {
      background: blue !important;
    }
    
    body.classic .color-btn.selected[style*="background: green"] {
      background: green !important;
    }
    
    /* クラシック - ペンの太さボタンのスタイル */
    body.classic .thickness-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 2px solid #ccc;
      margin: 0;
      cursor: pointer;
      background: #f9f9f9;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    body.classic .thickness-btn.selected {
      border: 3px solid #ffffff;
      box-shadow: 0 0 0 2px #333, 0 0 15px 3px rgba(51, 51, 51, 0.7), 0 4px 20px rgba(0,0,0,0.6);
      transform: scale(1.1);
      background: #ffffff;
    }
    .thickness-btn {
      min-width: 60px;
      padding: 5px 10px;
    }
    .thickness-btn.selected {
      background-color: #2196F3;
      color: white;
    }
    .star {
      position: absolute;
      width: 16px;
      height: 16px;
      background: gold;
      pointer-events: none;
      animation: starTwinkle 1s ease-out forwards;
      z-index: 10;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
    }
    
    /* 書き手側星エフェクト用CSS */
    .sender-star {
      position: fixed;
      width: 16px;
      height: 16px;
      background: gold;
      pointer-events: none;
      animation: senderStarTwinkle 1s ease-out forwards;
      z-index: 10000;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
    }
    
    @keyframes starTwinkle {
      0% {
        opacity: 1;
        transform: scale(0) rotate(0deg) translateX(0px) translateY(0px);
        filter: blur(0px);
      }
      30% {
        opacity: 1;
        transform: scale(1.2) rotate(180deg) translateX(10px) translateY(-10px);
        filter: blur(0px);
      }
      60% {
        opacity: 0.7;
        transform: scale(1.0) rotate(270deg) translateX(20px) translateY(-20px);
        filter: blur(1px);
      }
      85% {
        opacity: 0.3;
        transform: scale(0.6) rotate(330deg) translateX(25px) translateY(-25px);
        filter: blur(2px);
      }
      100% {
        opacity: 0;
        transform: scale(0.2) rotate(360deg) translateX(30px) translateY(-30px);
        filter: blur(3px);
      }
    }
    
    @keyframes senderStarTwinkle {
      0% {
        opacity: 1;
        transform: scale(0) rotate(0deg) translateX(0px) translateY(0px);
        filter: blur(0px);
      }
      30% {
        opacity: 1;
        transform: scale(1.2) rotate(180deg) translateX(10px) translateY(-10px);
        filter: blur(0px);
      }
      60% {
        opacity: 0.7;
        transform: scale(1.0) rotate(270deg) translateX(20px) translateY(-20px);
        filter: blur(1px);
      }
      85% {
        opacity: 0.3;
        transform: scale(0.6) rotate(330deg) translateX(25px) translateY(-25px);
        filter: blur(2px);
      }
      100% {
        opacity: 0;
        transform: scale(0.2) rotate(360deg) translateX(30px) translateY(-30px);
        filter: blur(3px);
      }
    }
    .fairy-dust {
      position: absolute;
      width: 3px;
      height: 3px;
      background: #fff;
      border-radius: 50%;
      pointer-events: none;
      animation: fairyDustTwinkle 3s ease-in-out forwards;
      z-index: 9;
      box-shadow: 0 0 8px #fff, 0 0 16px #fff, 0 0 24px #fff;
    }
    @keyframes fairyDustTwinkle {
      0% {
        opacity: 0;
        transform: scale(0) translateX(0px) translateY(0px);
        filter: blur(2px);
      }
      15% {
        opacity: 0.7;
        transform: scale(0.5) translateX(3px) translateY(-3px);
        filter: blur(1px);
      }
      30% {
        opacity: 1;
        transform: scale(1) translateX(8px) translateY(-8px);
        filter: blur(0px);
      }
      60% {
        opacity: 0.9;
        transform: scale(0.9) translateX(15px) translateY(-15px);
        filter: blur(0.5px);
      }
      80% {
        opacity: 0.5;
        transform: scale(0.6) translateX(20px) translateY(-20px);
        filter: blur(1.5px);
      }
      100% {
        opacity: 0;
        transform: scale(0.2) translateX(25px) translateY(-25px);
        filter: blur(3px);
      }
    }
    .heart {
      position: fixed;
      width: 25px;
      height: 25px;
      background: #ff69b4;
      right: 50px;
      bottom: 20px;
      pointer-events: none;
      z-index: 10000;
      transform: rotate(45deg);
    }
    .heart::before,
    .heart::after {
      content: '';
      width: 25px;
      height: 25px;
      position: absolute;
      background: #ff69b4;
      border-radius: 50%;
    }
    .heart::before {
      top: -12.5px;
      left: 0;
    }
    .heart::after {
      top: 0;
      left: -12.5px;
    }
    
    /* 描画エフェクト用の小さなハート */
    .drawing-heart {
      position: fixed;
      width: 12px;
      height: 12px;
      background: var(--heart-color, #ff1493);
      pointer-events: none;
      z-index: 10000;
      transform: rotate(45deg);
      animation: heartFloat 1.5s ease-out forwards;
      box-shadow: 0 0 8px var(--heart-color, #ff1493), 0 0 16px var(--heart-color, #ff1493);
    }
    .drawing-heart::before,
    .drawing-heart::after {
      content: '';
      width: 12px;
      height: 12px;
      position: absolute;
      background: var(--heart-color, #ff1493);
      border-radius: 50%;
    }
    .drawing-heart::before {
      top: -6px;
      left: 0;
    }
    .drawing-heart::after {
      top: 0;
      left: -6px;
    }
    
    @keyframes heartFloat {
      0% {
        opacity: 1;
        transform: rotate(45deg) scale(0.3) translateY(0px);
      }
      50% {
        opacity: 0.8;
        transform: rotate(45deg) scale(1) translateY(-20px);
      }
      100% {
        opacity: 0;
        transform: rotate(45deg) scale(0.5) translateY(-50px);
      }
    }
    
    /* 特別演出用の大きなハート */
    .special-heart {
      position: fixed;
      width: 120px;
      height: 120px;
      background: #ff1493;
      pointer-events: none;
      z-index: 99999;
      transform: rotate(45deg);
      box-shadow: 0 0 20px #ff1493, 0 0 40px #ff1493, 0 0 60px #ff1493;
    }
    .special-heart::before,
    .special-heart::after {
      content: '';
      width: 120px;
      height: 120px;
      position: absolute;
      background: #ff1493;
      border-radius: 50%;
      box-shadow: 0 0 20px #ff1493;
    }
    .special-heart::before {
      top: -60px;
      left: 0;
    }
    .special-heart::after {
      top: 0;
      left: -60px;
    }
    
    /* PC画面での新しいレイアウト */
    body.classic .canvas-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    
    body.classic .main-controls {
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
    }
    
    body.classic .pen-controls {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 10px 0;
    }
    
    body.classic .pen-colors {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    body.classic .pen-thickness {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    body.classic .background-controls {
      width: 100%;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    
    /* 縦向きタブレット用レイアウト */
    @media screen and (orientation: portrait) and (max-width: 1024px) {
      body {
        margin: 0;
        padding: 0;
        overflow-x: hidden;
      }
      
      .main-container {
        display: flex;
        flex-direction: column;
        padding: 10px;
        height: 100vh;
        box-sizing: border-box;
      }
      
      .canvas-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        margin-bottom: 10px;
      }
      
      #drawCanvas {
        width: 100% !important; /* ピンクエリアと同じサイズに固定 */
        height: 100% !important;
        transform: scale(1.3) !important; /* ピンクエリアと同じスケール */
        transform-origin: center !important;
        margin: 0 auto;
      }
      
      /* ボタングループのレイアウト調整 */
      .button-group {
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        margin-bottom: 10px;
      }
      
      /* 送信・クリアボタンは大きく */
      .canvas-container > .button-group:first-of-type button {
        font-size: 16px;
        padding: 15px 25px;
        min-width: 120px;
      }
      
      /* 色とペンのパネルを横並びに */
      .color-panel, .thickness-panel {
        display: none !important; /* 既存のパネルを非表示 */
      }
      
      /* 色・ペンセクションを完全に非表示 */
      .color-thickness-section {
        display: none !important; /* タブレットでも非表示 */
      }
      
      .color-row, .thickness-row {
        display: flex;
        justify-content: space-around;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      
      .color-row label, .thickness-row label {
        width: 100%;
        text-align: center;
        font-weight: bold;
        margin-bottom: 5px;
      }
      
      /* Dev Toolsボタンを右下に固定 */
      .button-group:has(button[onclick*="toggleDevTools"]) {
        position: fixed;
        bottom: 10px;
        right: 10px;
        margin: 0;
        z-index: 1000;
      }
      
      /* 背景選択ボタンを小さく */
      .button-group:has(button[onclick*="setBackground"]) {
        font-size: 12px;
      }
      
      /* 📱 縦向きタブレット用右サイドバーを横列に変更 */
      .right-sidebar {
        flex-direction: column !important;
        gap: 50px !important; /* 色と太さの間に50pxの間隔 */
        justify-content: center !important;
        align-items: center !important;
        width: 100% !important;
        margin-top: 30px !important; /* clearボタンから下に30px */
      }
      
      .pen-colors-vertical, .pen-thickness-vertical {
        flex-direction: row !important; /* 縦列から横列に変更 */
        gap: 15px !important;
        align-items: center !important;
      }
      
      .pen-colors-vertical h4, .pen-thickness-vertical h4 {
        margin: 0 15px 0 0 !important;
      }
      
      .button-group:has(button[onclick*="setBackground"]) button {
        padding: 8px 12px;
        font-size: 12px;
      }
      
      /* Writer IDステータスを上部に固定 */
      #writerStatus {
        position: fixed;
        top: 5px;
        right: 5px;
        z-index: 1001;
        font-size: 12px;
        padding: 5px 10px;
      }
      
      /* テーマトグルボタンを左上に */
      #themeToggle {
        position: fixed;
        top: 5px;
        left: 5px;
        z-index: 1001;
        padding: 5px 10px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body class="modern">
<button id="themeToggle" onclick="toggleTheme()">📝 クラシック</button>

<div class="main-container" style="display: flex; justify-content: center; align-items: flex-start; gap: 20px;">
<div class="canvas-container">
<div style="position: relative; display: inline-block; margin: 50px auto 20px auto;">
  <img src="back2.png" alt="背景画像" style="transform: scale(1.3); display: block;">
  <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: pink; transform: scale(1.3); transform-origin: center;"></div>
  <canvas id="drawCanvas" width="283" height="420" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scale(1.3); transform-origin: center; cursor: crosshair; background: transparent;"></canvas>
</div>

<!-- メインコントロール: Clear、自分だけ削除、送信 -->
<div class="main-controls">
  <button onclick="clearCanvas()">Clear</button>
  <button onclick="clearMyDrawing()" style="background-color: #FF6B6B; color: white;">自分だけ消去</button>
  <button onclick="saveDoubleRotatedImage()" style="background-color: #4CAF50; color: white; font-size: 18px; padding: 12px 24px; font-weight: bold;">渡す</button>
</div>

</div>

<!-- 右サイドバー: ペンの色と太さを並べて配置 -->
<div class="right-sidebar" style="display: flex; gap: 15px; margin-top: 20px;">
  <!-- 左列: 色 -->
  <div class="pen-colors-vertical" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
    <h4 style="margin: 0; font-size: 16px; color: #333;">色</h4>
    <button class="color-btn selected" style="background: black; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('black')"></button>
    <button class="color-btn" style="background: red; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('red')"></button>
    <button class="color-btn" style="background: blue; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('blue')"></button>
    <button class="color-btn" style="background: green; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('green')"></button>
    <button class="color-btn" style="background: white; border: 4px solid red; box-sizing: border-box; width: 50px; height: 50px; border-radius: 50%;" onclick="setPenColor('white-red-border')"></button>
  </div>
  
  <!-- 右列: 太さ -->
  <div class="pen-thickness-vertical" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
    <h4 style="margin: 0; font-size: 16px; color: #333;">太さ</h4>
    <button class="thickness-btn" onclick="setPenThickness(10)" title="太い (+30%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 21px; height: 21px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn" onclick="setPenThickness(8)" title="標準" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 16px; height: 16px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn selected" onclick="setPenThickness(6)" title="細い (-25%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #333; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 12px; height: 12px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn" onclick="setPenThickness(4)" title="とても細い (-50%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 8px; height: 8px; border-radius: 50%; background: #333;"></div>
    </button>
  </div>
</div>
</div>

<!-- 背景選択はDevToolに移動 -->




<div class="button-group">
  <button onclick="toggleDevTools()" style="background-color: #FFA500; color: white;">🔧 Dev Tool</button>
</div>

<div id="devTools" style="display: none; border: 2px solid orange; padding: 10px; margin-top: 10px;">
  <h3>開発者ツール</h3>
  
  <div class="button-group">
    <label>キャンバスサイズ調整:</label>
    <input type="range" id="canvasScale" min="0.1" max="3.0" step="0.05" value="0.7" oninput="updateCanvasScale(this.value)">
    <span id="canvasScaleValue">0.7x</span>
  </div>
  
  <div class="button-group">
    <label>アニメーション開始待機時間（秒）:</label>
    <input type="range" id="animationStartWait" min="0.1" max="10" step="0.1" value="3.3" oninput="updateAnimationStartWait(this.value)">
    <span id="animationStartWaitValue">3.3秒</span>
  </div>
  
  <div class="button-group">
    <label>回転後待機時間（秒）:</label>
    <input type="range" id="rotationWait" min="1" max="10" step="0.5" value="7.5" oninput="updateRotationWait(this.value)">
    <span id="rotationWaitValue">7.5秒</span>
  </div>
  
  <div class="button-group">
    <button onclick="sendDevSettings()">設定を受信側に送信</button>
  </div>
  
  <div class="button-group">
    <label>背景選択:</label>
    <button onclick="setBackground('./back3.png')">背景1</button>
    <button onclick="setBackground('./back2.png')">背景2</button>
    <button onclick="setBackground('./back4.png')">背景3</button>
    <button onclick="setBackground('./back6.png')">背景4</button>
    <button onclick="setBackground(null)">白</button>
    <button onclick="setSpecialBackgroundToggle()" style="background: linear-gradient(45deg, #ff1493, #00ffff); color: white;">🎬 動画背景</button>
  </div>
  
  <hr style="margin: 15px 0;">
  
  <div class="button-group">
    <label>テスト演出:</label>
    <button onclick="createFireworks()" style="background: linear-gradient(45deg, #ff4500, #ffd700); color: white;">🎆 花火テスト</button>
    <button onclick="createConfetti()" style="background: linear-gradient(45deg, #ff69b4, #00fa9a); color: white;">🎊 紙吹雪テスト</button>
  </div>
  
  <div class="button-group">
    <label>ビデオサイズ:</label>
    <button id="size100Btn" class="selected" onclick="setVideoSize(100)">100%</button>
    <button id="size90Btn" onclick="setVideoSize(90)">90%</button>
    <button id="size80Btn" onclick="setVideoSize(80)">80%</button>
  </div>
  
  <div class="button-group">
    <button onclick="playVideo()" style="background-color: #FF6B6B; color: white;">📹 ビデオ再生</button>
  </div>
  
  <div class="button-group">
    <label>エフェクト:</label>
    <input type="checkbox" id="starEffect" checked onchange="toggleStarEffect()">
    <label for="starEffect">星</label>
    <input type="checkbox" id="fairyDustEffect" onchange="toggleFairyDustEffect()" checked>
    <label for="fairyDustEffect">妖精の粉</label>
    <input type="checkbox" id="heartEffect" onchange="toggleHeartEffect()">
    <label for="heartEffect">💖 ハート</label>
    <input type="checkbox" id="penSoundEffect" onchange="togglePenSound()">
    <label for="penSoundEffect">🎵 ペン音</label>
  </div>
  
  <div class="button-group">
    <label>送信後演出:</label>
    <input type="checkbox" id="fireworksEffect" checked>
    <label for="fireworksEffect">🎆 花火</label>
    <input type="checkbox" id="confettiEffect" checked>
    <label for="confettiEffect">🎊 紙吹雪</label>
    <input type="checkbox" id="backgroundDebug" onchange="toggleBackgroundDebug()">
    <label for="backgroundDebug">🔍 背景デバッグ</label>
  </div>
  
  <div class="button-group">
    <label>用紙サイズ:</label>
    <button id="a4Btn" class="selected" onclick="setPaperSize('A4')">A4</button>
    <button id="lBtn" onclick="setPaperSize('L')">L判</button>
    <button id="posterBtn" onclick="setPaperSize('poster')">ポストカード</button>
  </div>
  
  <div class="button-group">
    <label>印刷モード:</label>
    <button id="drawOnlyBtn" class="selected" onclick="setPrintMode('drawOnly')">描画モード</button>
    <button id="fullModeBtn" onclick="setPrintMode('fullMode')">フルモード</button>
  </div>
  
  <hr style="margin: 15px 0;">
  
  <div class="button-group">
    <label>SwitchBot:</label>
    <input type="checkbox" id="switchBotEffect">
    <label for="switchBotEffect">🤖 バブル</label>
  </div>
  
  <div class="button-group">
    <button onclick="testSwitchBot()" style="background-color: #FF6B35; color: white;">🤖 Botテスト</button>
  </div>
  
  <div class="button-group">
    <label>座標テスト:</label>
    <button onclick="testDrawRightBottom()" style="background-color: #FF1493; color: white;">テスト右下</button>
  </div>
</div>

<div id="countdown"></div>

<script>
const canvas = document.getElementById("drawCanvas");
// console.log('🎯 canvas要素取得結果:', canvas);
// console.log('🎯 canvas要素のID:', canvas ? canvas.id : 'canvas要素が見つからない');

const ctx = canvas.getContext("2d");
// console.log('🎯 2Dコンテキスト取得結果:', ctx);
let drawing = false;
let socket = new WebSocket("wss://realtime-sign-server-1.onrender.com");
let myWriterId = null; // 自分のwriter ID
let otherWritersData = {}; // 他の執筆者のデータ

// 描画状態管理用グローバル変数
let isPaintDrawing = false;
let lastPaintPos = null;

// 背景画像の範囲を計算する関数（グローバル）
function getBackgroundArea() {
  if (!backgroundImage) {
    // 背景画像がない場合は全範囲を許可
    // console.log('🖼️ 背景画像なし - 全範囲を許可'); // 軽量化
    return {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height
    };
  }
  
  // drawBackgroundImage関数と同じ計算ロジック（2倍拡大を含む）
  const canvasRatio = canvas.width / canvas.height;
  const imageRatio = backgroundImage.width / backgroundImage.height;
  
  let baseWidth, baseHeight;
  
  // 基本サイズを計算（contain方式）
  if (imageRatio > canvasRatio) {
    // 画像の方が横長
    baseWidth = canvas.width;
    baseHeight = canvas.width / imageRatio;
  } else {
    // 画像の方が縦長
    baseHeight = canvas.height;
    baseWidth = canvas.height * imageRatio;
  }
  
  // 背景画像と描画エリアを同じサイズに
  const scale = 1.0;
  const drawWidth = baseWidth * scale;
  const drawHeight = baseHeight * scale;
  
  // 中央に配置するためのオフセット
  const offsetX = (canvas.width - drawWidth) / 2;
  const offsetY = (canvas.height - drawHeight) / 2;
  
  // console.log('🖼️ 背景画像範囲計算:', {
  //   canvasSize: { width: canvas.width, height: canvas.height },
  //   imageSize: { width: backgroundImage.width, height: backgroundImage.height },
  //   baseSize: { width: baseWidth, height: baseHeight },
  //   scale: scale,
  //   drawArea: { x: offsetX, y: offsetY, width: drawWidth, height: drawHeight }
  // }); // 軽量化
  
  return {
    x: offsetX,
    y: offsetY,
    width: drawWidth,
    height: drawHeight
  };
}

// 座標が背景画像の範囲内かチェックする関数（グローバル）
function isWithinBackgroundArea(x, y) {
  // 背景画像範囲チェックを再有効化して詳細ログ出力
  const bgArea = getBackgroundArea();
  
  const withinX = x >= bgArea.x && x <= bgArea.x + bgArea.width;
  const withinY = y >= bgArea.y && y <= bgArea.y + bgArea.height;
  const isWithin = withinX && withinY;
  
  // console.log('🖼️ 背景画像範囲チェック詳細:', {
  //   clickX: x,
  //   clickY: y,
  //   bgX: bgArea.x,
  //   bgY: bgArea.y,
  //   bgWidth: bgArea.width,
  //   bgHeight: bgArea.height,
  //   withinX: withinX,
  //   withinY: withinY,
  //   isWithin: isWithin
  // }); // 軽量化
  
  return isWithin;
}

let mySessionId = null; // セッション固有ID
let backgroundImage = null;
let currentPaperSize = "A4"; // 現在の用紙サイズ
let currentPrintMode = "drawOnly"; // 現在の印刷モード（デフォルト：描画モード）
let currentVideoSize = 100; // 現在のビデオサイズ（デフォルト100%）
let canvasScale = 0.7; // キャンバススケール
let animationStartWaitTime = 3.3; // アニメーション開始待機時間
let rotationWaitTime = 7.5; // 回転後待機時間
let currentPenThickness = 6; // 現在のペンの太さ（細い）
let currentPenColor = 'black'; // 現在のペンの色
let hasSentData = false; // 送信済みフラグ
// WriterID別の描画状態管理（書き手側用）
const writerDrawingStates = {};

// 現在の書き手用のレガシー変数（後方互換性のため保持）
let lastPosition = null; // 前回の位置を記録
// secondLastPosition変数を削除（パフォーマンス改善）
let currentPath = []; // 現在のストロークのポイント配列
let smoothingFactor = 0.3; // 曲線の滑らかさ（0-1の範囲）

// ベジェ曲線補間用の点履歴
let pointHistory = []; // 最新3点を保持してベジェ曲線を描画
const MAX_POINT_HISTORY = 3; // 保持する点の最大数
let starEffectEnabled = true; // 星エフェクトの有効/無効（標準でON）
let fairyDustEffectEnabled = true; // 妖精の粉エフェクトの有効/無効（標準でON）
let heartEffectEnabled = false; // ハートエフェクトの有効/無効（標準でOFF）
let penSoundEnabled = false; // ペン音の有効/無効（標準でOFF）
let specialBackgroundState = 'ready'; // 'ready', 'door_shown', 'door_opened'
let specialBackgroundToggle = false; // 特殊背景の画像を切り替えるフラグ

// 🎬 送信側動画背景関連変数
let senderVideoElement = null;
let isSenderVideoActive = false;

// 🎵 ペン音制御
let drawingAudio = null; // 描画中の音楽オブジェクト
let isDrawingActive = false; // 描画中フラグ
let drawingInactiveTimer = null; // 描画停止タイマー
const DRAWING_PAUSE_DELAY = 500; // 描画停止から一時停止までの遅延（ミリ秒）

// 🔍 背景デバッグ表示制御
let backgroundDebugEnabled = false;
let lastBackgroundSrc = null;

// 背景別キャンバスサイズ設定（1.02倍サイズ = 0.6*1.7）
const backgroundSizes = {
  'back3': { width: 859, height: 607 },    // 背景1 - 統一アスペクト比 (859/607 ≈ 1.415)
  'back2': { width: 859, height: 607 },    // 背景2 - 統一アスペクト比に変更
  'back4': { width: 859, height: 607 },    // 背景3 - 統一アスペクト比
  'back5': { width: 859, height: 607 },    // 背景5 - 統一アスペクト比
  'back6': { width: 859, height: 607 },    // 背景4 - 統一アスペクト比
  'white': { width: 859, height: 607 }     // 白背景 - 統一アスペクト比
};

// 🚀 非侵入的パフォーマンス最適化レイヤー
// 既存機能を一切変更せず、追加のみで最適化
let performanceOptimizer = {
  lastMouseTime: 0,
  lastTouchTime: 0,
  pendingEffects: [],
  effectAnimationId: null,
  MOUSE_THROTTLE_INTERVAL: 16, // PC用: 60fps相当
  TOUCH_THROTTLE_INTERVAL: 8,  // Redmi Pad 2軽量化: 360Hz→120Hz相当（125fps）
  
  // マウスイベントのスロットリングチェック（PC用）
  shouldProcessMouseEvent() {
    const now = Date.now();
    if (now - this.lastMouseTime < this.MOUSE_THROTTLE_INTERVAL) {
      return false;
    }
    this.lastMouseTime = now;
    return true;
  },
  
  // タッチイベントのスロットリングチェック（Redmi Pad 2最適化）
  shouldProcessTouchEvent() {
    const now = Date.now();
    if (now - this.lastTouchTime < this.TOUCH_THROTTLE_INTERVAL) {
      return false;
    }
    this.lastTouchTime = now;
    return true;
  },
  
  // エフェクト処理の遺延実行
  scheduleEffect(effectFunction) {
    this.pendingEffects.push(effectFunction);
    if (!this.effectAnimationId) {
      this.effectAnimationId = requestAnimationFrame(() => {
        // エフェクトをバッチ処理
        for (const effect of this.pendingEffects) {
          if (Math.random() < 0.3) { // 30%の確率で実行（パフォーマンス調整）
            effect();
          }
        }
        this.pendingEffects = [];
        this.effectAnimationId = null;
      });
    }
  }
};

socket.onopen = () => {
  console.log("✅ WebSocket接続完了（送信側）");
  
  // 少し待ってからwriter ID を要求（受信側の準備完了を待つ）
  setTimeout(() => {
    console.log("🔄 WriterID要求を開始");
    requestWriterId();
    
    // 初期背景画像の設定はWriterID割り当て完了後に実行するため、ここでは削除
    console.log('⏳ WriterID割り当て待ち - 背景画像送信はWriterID取得後に実行');
  }, 500);
};

socket.onmessage = (event) => {
  try {
    let data;
    
    // Blobの場合は文字列として読み取る
    if (event.data instanceof Blob) {
      const reader = new FileReader();
      reader.onload = function() {
        try {
          data = JSON.parse(reader.result);
          processMessage(data);
        } catch (error) {
          console.error('❌ Blobデータの解析エラー:', error);
        }
      };
      reader.readAsText(event.data);
      return;
    } else {
      // 文字列の場合
      data = JSON.parse(event.data);
      processMessage(data);
    }
  } catch (error) {
    console.error('❌ メッセージ処理エラー:', error);
  }
};

function processMessage(data) {
  // console.log(`📨 メッセージ受信: type=${data.type}, writerId=${data.writerId || 'なし'}`);
  // console.log(`📨 受信時の状態: hasSentData=${hasSentData}, drawingCommands数=${drawingCommands.length}, otherWritersDataキー数=${Object.keys(otherWritersData).length}`);
  if (Object.keys(otherWritersData).length > 0) {
    // console.log(`📨 現在のotherWritersData詳細:`, Object.keys(otherWritersData).map(key => `${key}:${otherWritersData[key].length}件`));
  }
  
  // ハートビート要求処理
  if (data.type === "ping") {
    // console.log("💓 ハートビート要求受信 - pong送信");
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "pong", timestamp: Date.now() }));
    }
    return;
  }
  
  if (data.type === "assignWriterId") {
    // writer ID の割り当てを受信
    console.log("📨 WriterID割り当てメッセージ受信（生データ）:", data);
    console.log("📊 自分のセッションID:", mySessionId);
    console.log("📊 メッセージのセッションID:", data.sessionId);
    
    // セッションIDが一致する場合のみログ出力と処理
    if (data.sessionId && data.sessionId === mySessionId) {
      console.log("✅ セッションID一致 - WriterID処理開始");
      // 既に同じWriterIDを持っている他のブラウザがいないかチェック
      if (data.conflictDetected) {
        console.warn("⚠️ WriterID重複検出！再割り当てを要求します");
        mySessionId = generateSessionId(); // 新しいセッションIDを生成
        setTimeout(() => {
          requestWriterId(); // 再要求
        }, 100);
        return;
      }
      
      console.log("📋 WriterID割り当て実行:", data.writerId);
      myWriterId = data.writerId;
      console.log(`📝 Writer ID 割り当て: ${myWriterId} (SessionID: ${mySessionId})`);
      document.title = `送信側 - ${myWriterId}`;
      
      // Writer ID表示を更新
      const statusDiv = document.getElementById('writerStatus') || createWriterStatusDiv();
      statusDiv.childNodes[1].textContent = `Writer ID: ${myWriterId}`;
      
      // 割り当て成功をサーバーに通知
      socket.send(JSON.stringify({
        type: "confirmWriterId",
        writerId: myWriterId,
        sessionId: mySessionId,
        timestamp: Date.now()
      }));
      
      // WriterID割り当て完了後に背景画像を受信側に送信
      console.log("🖼️ WriterID割り当て完了 - 背景画像を受信側に送信");
      setBackground('./back2.png');
    } else {
      // 他のクライアント向けのメッセージなので静かに無視（エラーではない）
      console.log("🔇 セッションID不一致のWriterID割り当てメッセージ（他クライアント向け）");
      console.log("  自分のセッション:", mySessionId);
      console.log("  メッセージのセッション:", data.sessionId);
    }
    
  } else if (data.type === "start" || data.type === "draw") {
    // 他の執筆者からの描画データを受信
    console.log(`🖊️ 描画データ受信: type=${data.type}, writerId=${data.writerId}, myWriterId=${myWriterId}, 他の書き手？${data.writerId !== myWriterId}`);
    
    if (data.writerId && data.writerId !== myWriterId) {
      console.log("✅ 他の書き手の描画として処理");
      handleOtherWriterDrawing(data);
    } else {
      console.log("❌ 自分の描画のため無視");
    }
  } else if (data.type === "clear") {
    // 受信側からの全体クリア
    console.log('🧹 受信側からのクリア指示でotherWritersDataをクリア');
    otherWritersData = {};
    
    // 遅延実行で重複処理を回避
    if (window.clearRedrawTimeout) {
      clearTimeout(window.clearRedrawTimeout);
    }
    
    window.clearRedrawTimeout = setTimeout(() => {
      redrawCanvasWithOthers();
      window.clearRedrawTimeout = null;
    }, 10);
  } else if (data.type === "globalClear") {
    // 他の書き手からの全体クリア（自分が送信者でない場合のみ処理）
    if (data.writerId !== myWriterId) {
      // console.log(`🧹 他の書き手(${data.writerId})からクリア指示を受信`);
      
      // キャンバスを完全にクリア
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (backgroundImage) {
        drawBackgroundImage(ctx, backgroundImage, canvas);
      }
      
      // 🔧【修正】全ての描画データをクリア（自分の描画も含む）
      otherWritersData = {};
      drawingCommands = []; // ✅ 自分の描画もクリアする
      console.log('🧹 他の書き手からのクリア指示：全描画データをクリア');
      
      // キャンバスを再描画（背景のみの状態にする）- 遅延実行
      if (window.globalClearRedrawTimeout) {
        clearTimeout(window.globalClearRedrawTimeout);
      }
      
      window.globalClearRedrawTimeout = setTimeout(() => {
        redrawCanvasWithOthers();
        window.globalClearRedrawTimeout = null;
      }, 10);
      
      // console.log('🧹 他の書き手からのクリア指示で完全クリア完了');
    }
  } else if (data.type === "clearWriter") {
    // 🔧【追加】特定の書き手の描画だけをクリア
    const writerId = data.writerId;
    
    // 自分が送信者でない場合のみ処理
    if (writerId !== myWriterId) {
      console.log(`🧹 書き手(${writerId})の描画クリア指示を受信`);
      
      // 該当書き手の描画データをクリア
      if (otherWritersData[writerId]) {
        delete otherWritersData[writerId];
        console.log(`🧹 ${writerId}の描画データを削除`);
      }
      
      // キャンバスを再描画（背景 + 残った描画）
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (backgroundImage) {
        drawBackgroundImage(ctx, backgroundImage, canvas);
      }
      
      // 再描画（自分の描画 + 他の書き手の描画）
      if (window.clearWriterRedrawTimeout) {
        clearTimeout(window.clearWriterRedrawTimeout);
      }
      
      window.clearWriterRedrawTimeout = setTimeout(() => {
        redrawCanvasWithOthers();
        window.clearWriterRedrawTimeout = null;
      }, 10);
      
      console.log(`✅ ${writerId}の描画クリア完了`);
    }
  } else if (data.type === "globalSend") {
    // 他の書き手からの送信実行（自分が送信者でない場合のみ処理）
    if (data.writerId !== myWriterId) {
      // console.log(`📤 他の書き手(${data.writerId})から送信実行を受信`);
      
      // 送信ボタンの無効化（他の人が送信中表示）
      const sendButton = document.querySelector('button[onclick="saveDoubleRotatedImage()"]');
      if (sendButton) {
        sendButton.style.backgroundColor = '#ffa500';
        sendButton.textContent = `${data.writerId}が送信中...`;
        sendButton.disabled = true;
        
        // 送信完了後にボタンを元に戻す
        setTimeout(() => {
          sendButton.style.backgroundColor = '';
          sendButton.textContent = '送信';
          sendButton.disabled = false;
        }, (data.animationStartWaitTime + data.rotationWaitTime + 10) * 1000); // 全体の処理時間
      }
      
      // 花火演出を他の書き手にも同期表示
      const fireworksCheckbox = document.getElementById('fireworksEffect');
      if (fireworksCheckbox && fireworksCheckbox.checked) {
        // console.log(`🎆 ${data.writerId}の送信に同期して花火演出を実行`);
        // 送信処理完了後少し遅れて花火を実行
        const fireworksDelay = (data.animationStartWaitTime + 3) * 1000; // アニメーション開始待機時間 + 3秒
        setTimeout(() => {
          createFireworks();
        }, fireworksDelay);
      }
      
      // 10秒後に自動クリア（送信処理と同期）
      setTimeout(() => {
        // console.log('🧹 他の書き手の送信に同期してクリア実行');
        
        // キャンバスをクリア
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (backgroundImage) {
          drawBackgroundImage(ctx, backgroundImage, canvas);
        }
        
        // 他のWriterの描画データのみクリア（自分の描画は保持）
        otherWritersData = {};
        // drawingCommands = []; // ❌ 自分の描画はクリアしない
        console.log('🧹 他の書き手の送信に同期：他writerデータのみクリア（自分の描画は保持）');
        console.log('🧹 自分の描画コマンド数（保持）:', drawingCommands.length);
        console.log('🧹 他writerデータクリア:', Object.keys(otherWritersData).length);
        
        // キャンバスを再描画 - 遅延実行で重複処理を回避
        if (window.globalSendRedrawTimeout) {
          clearTimeout(window.globalSendRedrawTimeout);
        }
        
        window.globalSendRedrawTimeout = setTimeout(() => {
          redrawCanvasWithOthers();
          window.globalSendRedrawTimeout = null;
        }, 10);
        
        // console.log('🧹 他の書き手の送信に同期してクリア完了');
      }, 10000);
    }
  } else if (data.type === "heartEffect") {
    // ハートエフェクト指示受信
    createHeart();
  } else if (data.type === "specialHeartEffect") {
    // 特別ハートエフェクト指示受信
    createSpecialHeart();
  } else if (data.type === "autoSelectBackground") {
    // console.log('🖼️ 受信側から背景自動選択指示を受信:', data.background);
    // 背景4を自動選択
    if (data.background === "back6") {
      setBackground('./back6.png');
      // console.log('🖼️ 背景4（back6.png）を自動選択');
    }
  }
}

// 背景画像をアスペクト比を保持して描画する関数（2倍サイズ・キャンバス自動調整）
function drawBackgroundImage(ctx, image, canvas) {
  if (!image) return;
  
  console.log('🖼️ 背景画像をキャンバス下に設定');
  console.log(`📥 画像サイズ: ${image.naturalWidth}x${image.naturalHeight}`);
  
  // キャンバスサイズはそのままで、CSSで背景画像を設定
  const canvasElement = document.getElementById('drawCanvas');
  if (canvasElement) {
    canvasElement.style.backgroundImage = `url(${image.src})`;
    canvasElement.style.backgroundSize = 'contain';
    canvasElement.style.backgroundRepeat = 'no-repeat';
    canvasElement.style.backgroundPosition = 'center';
    
    console.log(`✅ 背景画像をCSS背景として設定: ${image.src}`);
  }
}

// 不要なコントロール表示機能を削除 - シンプルなUIに統一

// デバイス検出と機能切り替えシステム
const DeviceManager = {
  // デバイスタイプを検出
  detectDevice() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    const touchSupport = 'ontouchstart' in window;
    const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;
    const maxTouchPoints = navigator.maxTouchPoints || 0;
    
    // タブレット判定
    const isTablet = (
      touchSupport &&
      maxTouchPoints > 1 &&
      (screenWidth >= 768 || screenHeight >= 768) &&
      (screenWidth <= 1024 || screenHeight <= 1024)
    ) || (
      /iPad|Android(?!.*Mobile)|Tablet/i.test(userAgent)
    );
    
    // スマートフォン判定
    const isMobile = (
      touchSupport &&
      !isTablet &&
      /Android|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)
    );
    
    // PC判定（デフォルト）
    const isPC = !isTablet && !isMobile;
    
    return {
      isPC,
      isTablet,
      isMobile,
      touchSupport,
      screenWidth,
      screenHeight,
      maxTouchPoints,
      userAgent: userAgent.substring(0, 100) // ログ用に短縮
    };
  },
  
  // デバイス別設定を適用
  applyDeviceSettings() {
    const device = this.detectDevice();
    console.log('🔍 デバイス検出結果:', device);
    
    if (device.isPC) {
      this.applyPCSettings();
    } else if (device.isTablet) {
      this.applyTabletSettings();
    } else if (device.isMobile) {
      this.applyMobileSettings();
    }
    
    return device;
  },
  
  // PC用設定
  applyPCSettings() {
    console.log('💻 PC設定を適用');
    
    // PC用の特別な設定
    const canvas = document.getElementById('drawCanvas');
    if (canvas) {
      // PCではマウス操作を最適化
      canvas.style.cursor = 'crosshair';
    }
    
    // PC用UIの調整
    document.body.classList.add('device-pc');
    document.body.classList.remove('device-tablet', 'device-mobile');
    
    // PC専用機能を有効化
    this.enablePCFeatures();
  },
  
  // タブレット用設定
  applyTabletSettings() {
    console.log('📱 タブレット設定を適用');
    
    // タブレット用の特別な設定
    const canvas = document.getElementById('drawCanvas');
    if (canvas) {
      // タブレットではタッチ操作を最適化
      canvas.style.cursor = 'none'; // カーソル非表示
    }
    
    // タブレット用UIの調整
    document.body.classList.add('device-tablet');
    document.body.classList.remove('device-pc', 'device-mobile');
    
    // タブレット専用機能を有効化
    this.enableTabletFeatures();
  },
  
  // モバイル用設定
  applyMobileSettings() {
    console.log('📱 モバイル設定を適用');
    
    // モバイル用の特別な設定
    const canvas = document.getElementById('drawCanvas');
    if (canvas) {
      canvas.style.cursor = 'none';
    }
    
    // モバイル用UIの調整
    document.body.classList.add('device-mobile');
    document.body.classList.remove('device-pc', 'device-tablet');
    
    // モバイル専用機能を有効化
    this.enableMobileFeatures();
  },
  
  // PC専用機能
  enablePCFeatures() {
    // PC用の詳細なDevToolsを表示
    const devButton = document.getElementById('devButton');
    if (devButton) {
      devButton.style.display = 'block';
    }
    
    // PC用のキーボードショートカットを有効化
    this.enableKeyboardShortcuts();
  },
  
  // タブレット専用機能
  enableTabletFeatures() {
    // タブレット用の大きなボタン
    const buttons = document.querySelectorAll('button');
    buttons.forEach(btn => {
      if (!btn.classList.contains('color-btn') && !btn.classList.contains('thickness-btn')) {
        btn.style.minHeight = '50px';
        btn.style.fontSize = '16px';
      }
    });
    
    // タブレット用のタッチ最適化
    this.optimizeForTouch();
  },
  
  // モバイル専用機能
  enableMobileFeatures() {
    // モバイル用の超大きなボタン
    const buttons = document.querySelectorAll('button');
    buttons.forEach(btn => {
      if (!btn.classList.contains('color-btn') && !btn.classList.contains('thickness-btn')) {
        btn.style.minHeight = '60px';
        btn.style.fontSize = '18px';
      }
    });
    
    // DevToolsを非表示（画面が小さいため）
    const devButton = document.getElementById('devButton');
    if (devButton) {
      devButton.style.display = 'none';
    }
  },
  
  // キーボードショートカット（PC専用）
  enableKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 'z':
            e.preventDefault();
            // Undo機能（将来実装）
            console.log('⌨️ Undo shortcut (PC only)');
            break;
          case 's':
            e.preventDefault();
            // Save機能
            console.log('⌨️ Save shortcut (PC only)');
            break;
        }
      }
    });
  },
  
  // タッチ最適化（タブレット/モバイル専用）
  optimizeForTouch() {
    // タッチ遅延を削除
    const style = document.createElement('style');
    style.textContent = `
      .device-tablet button, .device-mobile button {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        touch-action: manipulation;
      }
      
      .device-tablet .pen-controls, .device-mobile .pen-controls {
        gap: 15px;
      }
    `;
    document.head.appendChild(style);
  }
};

// セッションID生成関数
function generateSessionId() {
  // より一意性の高いセッションIDを生成
  const timestamp = Date.now();
  const nanoTime = performance.now() * 1000000; // ナノ秒精度に近づける
  const random1 = Math.random().toString(36).substr(2, 9);
  const random2 = Math.random().toString(36).substr(2, 9);
  const random3 = Math.random().toString(36).substr(2, 9);
  const random4 = Math.random().toString(36).substr(2, 9);
  const random5 = crypto.getRandomValues(new Uint32Array(1))[0].toString(36); // 暗号学的に安全な乱数
  
  // デバイス固有情報の収集（拡張）
  const screen = `${window.screen.width}x${window.screen.height}x${window.screen.colorDepth}`;
  const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const language = navigator.language || 'unknown';
  const platform = navigator.platform || 'unknown';
  const cookieEnabled = navigator.cookieEnabled ? '1' : '0';
  const onlineStatus = navigator.onLine ? '1' : '0';
  
  // 追加のブラウザ固有情報
  const userAgent = navigator.userAgent.length.toString(); // UAの長さ
  const vendor = navigator.vendor || 'unknown';
  const hardwareConcurrency = navigator.hardwareConcurrency || 'unknown';
  const deviceMemory = navigator.deviceMemory || 'unknown';
  const pixelRatio = window.devicePixelRatio || 'unknown';
  const touchPoints = navigator.maxTouchPoints || 'unknown';
  
  // より高精度なタイムスタンプ
  const performanceNow = performance.now().toString().replace('.', '');
  
  // キャンバスフィンガープリンティング（軽量版）
  let canvasFingerprint = 'unknown';
  try {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('Device fingerprint test', 2, 2);
      canvasFingerprint = canvas.toDataURL().slice(-10); // 最後の10文字のみ使用
    }
  } catch (e) {
    canvasFingerprint = 'canvas-error';
  }
  
  // すべての要素を結合
  const deviceInfo = `${screen}_${timezone}_${language}_${platform}_${cookieEnabled}_${onlineStatus}_${userAgent}_${vendor}_${hardwareConcurrency}_${deviceMemory}_${pixelRatio}_${touchPoints}_${canvasFingerprint}`;
  
  // ブラウザフィンガープリント（より長い）
  const fingerprint = btoa(deviceInfo).replace(/[^a-zA-Z0-9]/g, '').substr(0, 16);
  
  // localStorage/sessionStorageを使った永続的な識別子
  let storageId = '';
  try {
    // 既存のストレージIDを確認
    storageId = localStorage.getItem('senderBrowserId') || '';
    if (!storageId) {
      // 新規生成
      storageId = `browser_${crypto.getRandomValues(new Uint32Array(2)).join('_')}_${Date.now()}`;
      localStorage.setItem('senderBrowserId', storageId);
    }
  } catch (e) {
    // localStorage使用不可の場合
    storageId = 'no_storage';
  }
  
  const sessionId = `session_${random1}_${random2}_${random3}_${random4}_${random5}_${timestamp}_${nanoTime.toString().replace('.', '')}_${performanceNow}_${fingerprint}_${storageId}`;
  console.log("🆔 生成されたセッションID:", sessionId);
  console.log("🔍 デバイス情報:", {
    screen, timezone, language, platform, userAgent: userAgent, 
    vendor, hardwareConcurrency, deviceMemory, pixelRatio, touchPoints, 
    canvasFingerprint, storageId, nanoTime
  });
  return sessionId;
}

// Writer ID要求関数
function requestWriterId() {
  console.log("🔄 requestWriterId関数呼び出し");
  console.log("📊 WebSocket状態:", socket ? socket.readyState : 'socket未初期化');
  console.log("📊 WebSocket.OPEN定数:", WebSocket.OPEN);
  
  if (socket && socket.readyState === WebSocket.OPEN) {
    // セッションIDが未設定の場合は生成
    if (!mySessionId) {
      mySessionId = generateSessionId();
      console.log("🆔 セッションID生成:", mySessionId);
    }
    
    const requestMsg = {
      type: "requestWriterId",
      sessionId: mySessionId
    };
    console.log("📤 Writer ID要求送信:", requestMsg);
    socket.send(JSON.stringify(requestMsg));
    
    // 要求後の確認（自動再試行機能付き）
    let retryCount = 0;
    const maxRetries = 5; // 再試行回数を増加
    
    const checkAndRetry = () => {
      setTimeout(() => {
        // WebSocket接続状態を確認
        if (socket.readyState !== WebSocket.OPEN) {
          console.warn("⚠️ WebSocket接続が切断されています - Writer ID割り当て中断");
          alert('❌ WebSocket接続が切断されました\n\nページをリロードしてください');
          return;
        }
        
        if (myWriterId) {
          // ステータス表示を更新
          const statusDiv = document.getElementById('writerStatus');
          if (statusDiv) {
            statusDiv.childNodes[0].textContent = `Writer ID: ${myWriterId}`;
          }
          // console.log(`✅ Writer ID割り当て成功: ${myWriterId} (${retryCount + 1}回目で成功)`);
        } else {
          retryCount++;
          if (retryCount < maxRetries) {
            // console.log(`🔄 Writer ID再試行 ${retryCount}/${maxRetries}`);
            
            // 再試行前にセッションIDを再生成（長時間待機後の問題対策）
            if (retryCount > 2) {
              mySessionId = generateSessionId();
              // console.log("🔄 セッションID再生成:", mySessionId);
            }
            
            // 再試行
            socket.send(JSON.stringify({
              type: "requestWriterId",
              sessionId: mySessionId
            }));
            checkAndRetry();
          } else {
            alert('❌ Writer ID割り当て失敗\n\n対処法:\n1. 受信側を先に起動してください\n2. ページをリロードしてください\n3. しばらく待ってから再試行してください');
          }
        }
      }, 3000); // 再試行間隔を3秒に延長
    };
    
    checkAndRetry();
  } else {
    console.error("❌ WebSocket未接続 - 状態:", socket ? socket.readyState : 'socket未初期化');
    alert('❌ WebSocket未接続\n\nページをリロードしてください');
  }
}

// Writer ID ステータス表示div を作成
function createWriterStatusDiv() {
  const statusDiv = document.createElement('div');
  statusDiv.id = 'writerStatus';
  statusDiv.style.cssText = `
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 1000;
  `;
  
  // Version情報を表示
  const versionSpan = document.createElement('span');
  versionSpan.textContent = 'v3.8-quiet (描画ログ削除版)';
  versionSpan.style.cssText = `
    display: block;
    color: #FFD700;
    font-weight: bold;
    margin-bottom: 4px;
  `;
  statusDiv.appendChild(versionSpan);
  
  // Writer IDテキストノード
  const writerIdText = document.createTextNode('Writer ID: 接続中...');
  statusDiv.appendChild(writerIdText);
  
  // デバッグ用テストボタンを追加
  const testBtn = document.createElement('button');
  testBtn.textContent = 'ID確認';
  testBtn.style.cssText = `
    margin-left: 8px;
    font-size: 10px;
    padding: 3px 8px;
    background: #333;
    color: white;
    border: 1px solid #666;
    border-radius: 3px;
    cursor: pointer;
  `;
  testBtn.onclick = () => {
    console.log(`🔍 現在のWriter ID: ${myWriterId}`);
    console.log(`🔍 WebSocket状態: ${socket ? socket.readyState : 'socket未初期化'}`);
    console.log(`🔍 セッションID: ${mySessionId}`);
    console.log(`🔍 他の書き手データ:`, otherWritersData);
    
    let message = `Version: 3.1-fixed\nWriter ID: ${myWriterId || '未割り当て'}\nWebSocket: ${socket ? socket.readyState : '未初期化'}\nセッションID: ${mySessionId || '未生成'}\n他の書き手: ${Object.keys(otherWritersData).length}人`;
    
    if (!myWriterId) {
      message += '\n\n🔄 Writer IDを再要求しますか？';
      if (confirm(message)) {
        console.log("🔄 手動でWriterID要求を実行");
        requestWriterId();
      }
    } else {
      alert(message);
    }
  };
  statusDiv.appendChild(testBtn);
  
  document.body.appendChild(statusDiv);
  return statusDiv;
}

// 他の執筆者の描画データを処理
function handleOtherWriterDrawing(data) {
  const writerId = data.writerId;
  
  console.log(`📋 DEBUG: 他Writer受信前 - 自分の描画=${drawingCommands.length}件`);
  
  if (!otherWritersData[writerId]) {
    otherWritersData[writerId] = [];
  }
  
  otherWritersData[writerId].push(data);
  
  // 重複する再描画要求をまとめるため、少し遅延させる
  if (window.redrawTimeout) {
    clearTimeout(window.redrawTimeout);
  }
  
  window.redrawTimeout = setTimeout(() => {
    console.log(`📋 DEBUG: 再描画直前 - 自分の描画=${drawingCommands.length}件`);
    redrawCanvasWithOthers();
    window.redrawTimeout = null;
  }, 10);
}

// WriterID別パス状態管理（書き手側用）
const senderWriterPathStates = {};

// Writer別に独立した描画関数
function drawWriterCommands(commands, writerId, isMyself = false) {
  if (!Array.isArray(commands) || commands.length === 0) {
    return;
  }
  
  if (isMyself) {
    console.log(`📋 DEBUG: 自分の描画実行 - ${commands.length}件`);
  }
  
  // このWriterのパス状態を完全にリセット（他Writerとの混在防止）
  senderWriterPathStates[writerId] = {
    prevCmd: null
  };
  
  const writerState = senderWriterPathStates[writerId];
  
  ctx.save();
  
  // Canvas状態を完全にクリア（他WriterIDとの状態混在を防止）
  ctx.beginPath(); // 重要：前のパスをクリア
  ctx.setTransform(1, 0, 0, 1, 0, 0); // 変換行列をリセット
  
  // デフォルト描画設定を完全にリセット
  ctx.globalAlpha = isMyself ? 1.0 : 0.7;
  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';
  ctx.globalCompositeOperation = 'source-over';
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  let startCount = 0;
  let drawCount = 0;
  
  commands.forEach((cmd, index) => {
    if (cmd.type === "start") {
      startCount++;
      // startコマンド時にこのWriterのパス状態を完全にリセット
      ctx.beginPath(); // 前のパスをクリア
      ctx.moveTo(cmd.x, cmd.y); // 開始点を設定
      writerState.prevCmd = cmd;
      
      if (index === 0) {
        const isValid = cmd.x >= 0 && cmd.x <= canvas.width && cmd.y >= 0 && cmd.y <= canvas.height;
        console.log(`    🎯 最初のstart: x=${cmd.x}, y=${cmd.y} (canvas: ${canvas.width}x${canvas.height}) 範囲内？${isValid}`);
      }
    } else if (cmd.type === "draw" && writerState.prevCmd) {
      drawCount++;
      if (cmd.color === 'white-red-border') {
        // 白地赤縁の特別処理
        if (writerState.prevCmd) {
          // 外側の薄い赤を描画
          ctx.beginPath();
          ctx.moveTo(writerState.prevCmd.x, writerState.prevCmd.y);
          ctx.lineWidth = (cmd.thickness || (isMyself ? currentPenThickness : 4)) + 8;
          ctx.globalAlpha = isMyself ? 0.3 : 0.2;
          ctx.strokeStyle = '#ffccdd';
          ctx.shadowColor = '#ffccdd';
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.lineTo(cmd.x, cmd.y);
          ctx.stroke();
          ctx.closePath(); // パス終了
          
          // 内側の濃い赤を描画
          ctx.beginPath();
          ctx.moveTo(writerState.prevCmd.x, writerState.prevCmd.y);
          ctx.lineWidth = (cmd.thickness || (isMyself ? currentPenThickness : 4)) + 6;
          ctx.globalAlpha = isMyself ? 0.8 : 0.6;
          ctx.strokeStyle = '#ff88bb';
          ctx.shadowColor = '#ff88bb';
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.lineTo(cmd.x, cmd.y);
          ctx.stroke();
          ctx.closePath(); // パス終了
          
          // 白い中心を描画（グロー効果付き）
          ctx.beginPath();
          ctx.moveTo(writerState.prevCmd.x, writerState.prevCmd.y);
          ctx.globalAlpha = isMyself ? 0.9 : 0.7;
          ctx.lineWidth = Math.max(1, (cmd.thickness || (isMyself ? currentPenThickness : 4)) - 3);
          ctx.strokeStyle = '#ffffff';
          ctx.shadowColor = '#ffffff';
          ctx.lineTo(cmd.x, cmd.y);
          ctx.stroke();
          ctx.closePath(); // パス終了
          ctx.globalAlpha = isMyself ? 1.0 : 0.7; // 透明度をリセット
        }
      } else {
        // 通常の色の描画（各線分を完全独立して描画）
        ctx.beginPath(); // 必須：新しいパスを開始
        ctx.moveTo(writerState.prevCmd.x, writerState.prevCmd.y);
        ctx.lineWidth = cmd.thickness || (isMyself ? currentPenThickness : 4);
        ctx.strokeStyle = cmd.color || (isMyself ? currentPenColor : 'black');
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineTo(cmd.x, cmd.y);
        ctx.stroke(); // 各線分を即座に描画
        ctx.closePath(); // 重要：パスを完全に終了してWriter間の混在を防止
      }
      writerState.prevCmd = cmd;
    }
  });
  
  // 画面外描画の警告チェック
  let outOfBoundsCount = 0;
  commands.forEach(cmd => {
    if (cmd.x < 0 || cmd.x > canvas.width || cmd.y < 0 || cmd.y > canvas.height) {
      outOfBoundsCount++;
    }
  });
  
  if (isMyself) {
    console.log(`📋 DEBUG: 自分の描画完了 - start=${startCount}件, draw=${drawCount}件`);
  }
  
  // Canvas状態を完全にクリア（次のWriter描画との混在防止）
  ctx.beginPath(); // 重要：このWriterのパスを完全終了
  ctx.restore();
}

// 自分と他執筆者の描画を統合して再描画
// 再描画中フラグを追加して重複実行を防止
let isRedrawing = false;

function redrawCanvasWithOthers() {
  if (isRedrawing) {
    return;
  }
  
  isRedrawing = true;
  console.log(`📋 DEBUG: 再描画開始 - 自分=${drawingCommands.length}件, 他=${Object.keys(otherWritersData).length}人`);
  
  if (!Array.isArray(drawingCommands)) {
    isRedrawing = false;
    return;
  }
  
  // 🔥 現在描画中の場合は、現在の描画状態を保存
  let currentDrawingState = null;
  if (drawing) {
    const selfState = getWriterDrawingState('self');
    if (selfState && selfState.lastPosition && selfState.isDrawing) {
      currentDrawingState = {
        lastPosition: { ...selfState.lastPosition },
        penColor: currentPenColor,
        penThickness: currentPenThickness
      };
    }
  }
  
  // 背景をクリア
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // 背景画像があれば描画
  if (backgroundImage) {
    drawBackgroundImage(ctx, backgroundImage, canvas);
  }
  
  // 自分の描画コマンドを再実行
  ctx.save();
  ctx.beginPath();
  console.log(`📋 DEBUG: 自分の描画実行開始 - ${drawingCommands.length}件`);
  drawWriterCommands(drawingCommands, myWriterId, true);
  ctx.restore();
  
  // 他執筆者の描画データを描画（完全分離）
  Object.keys(otherWritersData).forEach(writerId => {
    ctx.save();
    
    // Canvas状態を完全にリセット（Writer間の干渉を防止）
    ctx.beginPath();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1.0;
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
    
    console.log(`📋 DEBUG: 他Writer[${writerId}]描画開始`);
    drawWriterCommands(otherWritersData[writerId], writerId, false);
    
    // Writer描画完了後、状態を完全クリア
    ctx.beginPath(); // 重要：このWriterのパスを完全終了
    ctx.restore();
    console.log(`📋 DEBUG: 他Writer[${writerId}]描画完了`);
  });
  
  // 現在描画中だった場合、描画状態を復元
  if (drawing && currentDrawingState) {
    ctx.beginPath();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1.0;
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    ctx.lineWidth = currentDrawingState.penThickness;
    if (currentDrawingState.penColor === 'white-red-border') {
      ctx.strokeStyle = '#ffffff';
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = Math.max(1, currentDrawingState.penThickness - 3);
    } else {
      const actualColor = currentDrawingState.penColor === 'black' ? '#000' : (currentDrawingState.penColor === 'white' ? '#fff' : (currentDrawingState.penColor === 'green' ? '#008000' : (currentDrawingState.penColor === 'pink' ? '#ff69b4' : currentDrawingState.penColor)));
      ctx.strokeStyle = actualColor;
    }
    
    ctx.moveTo(currentDrawingState.lastPosition.x, currentDrawingState.lastPosition.y);
  }

  console.log(`📋 DEBUG: 再描画完了 - 自分=${drawingCommands.length}件`);
  isRedrawing = false;
}

socket.onerror = (error) => console.error("❌ WebSocketエラー（送信側）:", error);
socket.onclose = (event) => {
  console.log("⚠️ WebSocket切断（送信側）:", event.code, event.reason);
  console.log("🧹 切断前の状態:", { myWriterId, mySessionId });
  
  // 接続切断時にセッション情報をリセット
  mySessionId = null;
  myWriterId = null;
  console.log("🧹 WebSocket切断に伴いセッション情報をリセット");
  
  // Writer ID表示をクリア
  const statusDiv = document.getElementById('writerStatus');
  if (statusDiv) {
    statusDiv.childNodes[0].textContent = 'Writer ID: 未割り当て';
  }
  document.title = '送信側 - 未接続';
};

// ハートエフェクト生成関数
// createHeart関数はspecial-effects.jsに移動しました

// createSpecialHeart関数はspecial-effects.jsに移動しました


// 送信側でもlキーでハートを表示（テスト用）
let senderLKeyCount = 0;
let senderLKeyTimer = null;

document.addEventListener('keydown', function(event) {
  if (event.key.toLowerCase() === 'l') {
    senderLKeyCount++;
    // 送信側lキー押下
    
    if (senderLKeyTimer) {
      clearTimeout(senderLKeyTimer);
    }
    
    if (senderLKeyCount >= 10) {
      // console.log('🎉 送信側でl10回達成 - 特別演出テスト');
      createSpecialHeart();
      senderLKeyCount = 0;
    } else {
      createHeart();
    }
    
    senderLKeyTimer = setTimeout(() => {
      senderLKeyCount = 0;
      // console.log('⏰ 送信側lキーカウントリセット');
    }, 3000);
  }
});

// テスト用：5秒後に自動でハートを表示
setTimeout(() => {
  // テスト: 自動ハート表示
  createHeart();
}, 5000);

// 🔸 用紙サイズ設定関数
function setPaperSize(size) {
  currentPaperSize = size;
  
  // ボタンの選択状態を更新
  document.getElementById("a4Btn").classList.remove("selected");
  document.getElementById("lBtn").classList.remove("selected");
  document.getElementById("posterBtn").classList.remove("selected");
  
  if (size === "A4") {
    document.getElementById("a4Btn").classList.add("selected");
    // console.log("📄 用紙サイズをA4に設定");
  } else if (size === "L") {
    document.getElementById("lBtn").classList.add("selected");
    // console.log("📄 用紙サイズをL判に設定");
  } else if (size === "poster") {
    document.getElementById("posterBtn").classList.add("selected");
    // console.log("📄 用紙サイズをポストカードに設定");
  }
  
  // 受信側に用紙サイズ情報を送信
  socket.send(JSON.stringify({ 
    type: "paperSize", 
    size: size 
  }));
}

// 🖨️ 印刷モード設定関数
function setPrintMode(mode) {
  currentPrintMode = mode;
  
  // ボタンの選択状態を更新
  document.getElementById("drawOnlyBtn").classList.remove("selected");
  document.getElementById("fullModeBtn").classList.remove("selected");
  
  if (mode === "drawOnly") {
    document.getElementById("drawOnlyBtn").classList.add("selected");
    // 印刷モードを描画モードに設定
  } else if (mode === "fullMode") {
    document.getElementById("fullModeBtn").classList.add("selected");
    // 印刷モードをフルモードに設定
  }
  
  // 受信側に印刷モード情報を送信
  socket.send(JSON.stringify({ 
    type: "printMode", 
    mode: mode 
  }));
}

// 🔸 キャンバスサイズ変更関数を追加
function setCanvasToPortraitSize() {
  // 背景画像と同じサイズに変更
  canvas.width = 283;
  canvas.height = 420;
  
  // 🔸 HTML要素のサイズも変更
  canvas.setAttribute('width', '283');
  canvas.setAttribute('height', '420');
  canvas.style.width = '283px';
  canvas.style.height = '420px';
  
  // console.log(`書き手側キャンバスを縦長に変更: ${canvas.width} x ${canvas.height}`);
}

function resetCanvasToNormalSize() {
  // 背景画像と同じサイズに戻す
  canvas.width = 283;
  canvas.height = 420;
  
  // 🔸 HTML要素のサイズも変更
  canvas.setAttribute('width', '283');
  canvas.setAttribute('height', '420');
  canvas.style.width = '283px';
  canvas.style.height = '420px';
  
  // console.log(`書き手側キャンバスを通常サイズに変更: ${canvas.width} x ${canvas.height}`);
}

function setBackground(src) {
  // console.log('setBackground関数呼び出し:', src, 'WebSocket状態:', socket ? socket.readyState : 'socket未初期化');
  
  // 背景変更時に他のwriterの古いデータをクリア
  // ※ 自分が明示的に背景を変更した場合のみクリアする（初期化時は除く）
  if (lastBackgroundSrc !== undefined && lastBackgroundSrc !== src) {
    // console.log('🧹 背景変更: 他のwriter描画データをクリア');
    otherWritersData = {};
  }
  
  if (src === null) {
    backgroundImage = null;
    
    // 🔸 白背景の場合も縦長サイズを設定（背景画像と同じ傾向）
    canvas.width = 400;  // 幅（横）
    canvas.height = 600; // 高さ（縦）
    
    console.log(`📄 白背景縦長確認: 幅${canvas.width} < 高さ${canvas.height} = ${canvas.width < canvas.height ? '縦長' : '横長'}`);
    
    console.log(`📄 白背景キャンバス: ${canvas.width}x${canvas.height}`);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 🔧 WebSocket接続状態を確認してから白背景データを送信
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ 
        type: "background", 
        src: "white",
        writerId: myWriterId,
        canvasSize: { 
          width: canvas.width,
          height: canvas.height 
        },
        scale: canvasScale,
        originalSize: backgroundSizes['white']
      }));
      
      console.log(`📡 白背景とキャンバスサイズを受信側に送信: ${canvas.width}x${canvas.height}`);
    } else {
      console.log(`⚠️ WebSocket未接続のため白背景データ送信をスキップ (状態: ${socket?.readyState})`);
    }
  } else {
    const img = new Image();
    img.src = src;
    // console.log("🔍 背景画像読み込み開始:", src);
    
    img.onload = () => {
      // console.log("✅ 背景画像読み込み成功:", src);
      backgroundImage = img;
      
      // 🔸 背景画像キーを取得（後で参照用）
      const backgroundKey = src.includes('back3') ? 'back3' : (src.includes('back4') ? 'back4' : (src.includes('back5') ? 'back5' : (src.includes('back6') ? 'back6' : 'back2')));
      
      // ⚠️ setCanvasSize()を削除 - drawBackgroundImage()でサイズ決定
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // アスペクト比を保持して描画
      const imageAspect = img.naturalWidth / img.naturalHeight;
      const canvasAspect = canvas.width / canvas.height;
      
      let drawWidth, drawHeight, offsetX, offsetY;
      
      if (imageAspect > canvasAspect) {
        // 画像が横長の場合、幅をキャンバス幅に合わせる
        drawWidth = canvas.width;
        drawHeight = drawWidth / imageAspect;
        offsetX = 0;
        offsetY = (canvas.height - drawHeight) / 2;
      } else {
        // 画像が縦長の場合、高さをキャンバス高さに合わせる
        drawHeight = canvas.height;
        drawWidth = drawHeight * imageAspect;
        offsetX = (canvas.width - drawWidth) / 2;
        offsetY = 0;
      }
      
      // 全背景で統一されたアスペクト比処理を使用
      
      // 書き手側では背景画像を回転なしで表示
      drawBackgroundImage(ctx, backgroundImage, canvas);
      
      // 背景ソースを記録
      lastBackgroundSrc = src;
      
      // 🔍 背景画像の配置情報を詳細表示
      // console.log(`🖼️ 背景画像配置詳細 [${src}]:`);
      // console.log(`  キャンバスサイズ: ${canvas.width}x${canvas.height}`);
      // console.log(`  元画像サイズ: ${img.naturalWidth}x${img.naturalHeight}`);
      // console.log(`  描画サイズ: ${drawWidth.toFixed(1)}x${drawHeight.toFixed(1)}`);
      // console.log(`  描画位置: (${offsetX.toFixed(1)}, ${offsetY.toFixed(1)})`);
      // console.log(`  画像の占有率: ${((drawWidth * drawHeight) / (canvas.width * canvas.height) * 100).toFixed(1)}%`);
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const bgCenterX = offsetX + drawWidth / 2;
      const bgCenterY = offsetY + drawHeight / 2;
      // console.log(`  キャンバス中心: (${centerX}, ${centerY}) 緑点`);
      // console.log(`  背景画像中心: (${bgCenterX.toFixed(1)}, ${bgCenterY.toFixed(1)}) 青点`);
      
      // 🔍 デバッグ表示が有効な場合のみ視覚的な表示を追加
      if (backgroundDebugEnabled) {
        addBackgroundDebugVisuals(offsetX, offsetY, drawWidth, drawHeight);
      }
      
      // 🔧 WebSocket接続状態を確認してから背景画像データを送信
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ 
          type: "background", 
          src: src,
          writerId: myWriterId,
          canvasSize: { 
            width: canvas.width,
            height: canvas.height 
          },
          scale: canvasScale,
          originalSize: backgroundSizes[backgroundKey]
        }));
        
        console.log(`📡 背景画像とキャンバスサイズを受信側に送信: ${canvas.width}x${canvas.height}`);
      } else {
        console.log(`⚠️ WebSocket未接続のため背景画像データ送信をスキップ (状態: ${socket?.readyState})`);
      }
    };
    
    img.onerror = (error) => {
      console.error("❌ 背景画像読み込みエラー:", src, error);
      alert("背景画像が見つかりません: " + src);
    };
  }
}

// 🔸 特殊背景設定関数（扉開く演出付き）
function setSpecialBackground(src) {
  // console.log(`🚪 特殊背景設定開始: ${src}`);
  
  // 受信側に扉アニメーション開始を通知
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      type: "doorAnimation",
      imageSrc: src
    }));
    // console.log('🚪 受信側に扉アニメーション開始を送信');
  }
}

// 🔸 キャンバスサイズ設定関数
function setCanvasSize(backgroundKey) {
  // ❌ この関数を無効化 - drawBackgroundImageでサイズ管理
  console.log(`⚠️ setCanvasSize(${backgroundKey})は無効化されました`);
  return;
  
  // console.log(`📐 送信側キャンバスサイズ変更: ${size.width} x ${size.height}`);
}

// 🎪 特殊背景設定関数（ドア開閉アニメーション付き）
function setSpecialBackground(src) {
  // console.log('🎪 特殊背景設定開始:', src, 'State:', specialBackgroundState);
  
  if (specialBackgroundState === 'ready') {
    // 第1段階: 扉を表示して停止
    // console.log('🚪 第1段階: 扉表示');
    specialBackgroundState = 'door_shown';
    
    // 受信側に扉表示のみを通知
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ 
        type: "doorAnimation", 
        action: "show_door_only",
        backgroundSrc: src
      }));
      // console.log('🚪 受信側に扉表示のみを送信');
    }
    
    // 送信側でも視覚的フィードバック
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 背景画像を事前に読み込み
    const img = new Image();
    img.src = src;
    img.onload = () => {
      backgroundImage = img;
      // console.log("✅ 特殊背景画像読み込み成功（待機中）:", src);
    };
    
  } else if (specialBackgroundState === 'door_shown') {
    // 第2段階: 扉を開く
    // console.log('🚪 第2段階: 扉開放');
    specialBackgroundState = 'door_opened';
    
    // 受信側に扉開放を通知
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ 
        type: "doorAnimation", 
        action: "open_door",
        backgroundSrc: src
      }));
      // console.log('🚪 受信側に扉開放を送信');
    }
    
    // 1秒後に背景を設定（ドアが開くタイミング）
    setTimeout(() => {
      if (backgroundImage) {
        // console.log("✅ 特殊背景画像設定開始:", src);
        
        // 背景画像キーを取得（参照用）
        const backgroundKey = src.includes('back3') ? 'back3' : (src.includes('back4') ? 'back4' : (src.includes('back5') ? 'back5' : (src.includes('back6') ? 'back6' : 'back2')));
        
        // ⚠️ setCanvasSize()を削除 - drawBackgroundImage()でサイズ決定
        
        // キャンバスをクリアして背景を描画
        ctx.restore();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackgroundImage(ctx, backgroundImage, canvas);
        
        // 受信側に背景変更を通知
        socket.send(JSON.stringify({ 
          type: "specialBackground", 
          src: src,
          canvasSize: backgroundSizes[backgroundKey],
          doorAction: "opened"
        }));
        
        // 特別なエフェクトを追加（星や妖精の粉を散らす）
        for (let i = 0; i < 10; i++) {
          setTimeout(() => {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            if (starEffectEnabled) {
              createStar(x, y);
            }
            if (fairyDustEffectEnabled) {
              createFairyDust(x, y);
            }
          }, i * 100);
        }
        
        // 特別な音を再生（sound1.mp3を削除）
        
        // 🎪 背景が正常に適用されたのでトグルフラグを反転
        specialBackgroundToggle = !specialBackgroundToggle;
        // console.log(`🎪 背景適用完了 - フラグを反転: ${specialBackgroundToggle}`);
        // console.log(`🎪 次回使用予定: ${specialBackgroundToggle ? 'back5.png' : 'back4.png'}`);
        
        // 状態をリセット
        specialBackgroundState = 'ready';
      }
    }, 1000); // ドア開閉アニメーションの時間
  }
}

// 🎪 特殊背景設定関数（back6.mp4動画を使用）
function setSpecialBackgroundToggle() {
  // console.log('動画背景ボタン押下 - WebSocket状態:', socket ? socket.readyState : 'socket未初期化');
  // console.log('特殊背景ボタン押下（動画モード） - 現在の状態:', specialBackgroundState);
  
  if (specialBackgroundState === 'ready') {
    // 第1段階: 扉を表示して動画を最初のフレームで停止
    // console.log('🚪 第1段階: 扉表示と動画準備');
    specialBackgroundState = 'door_shown';
    
    // 送信側にも動画を配置
    createSenderVideo();
    
    // 受信側に動画背景開始を通知
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ 
        type: "videoBackground", 
        action: "prepare",
        videoSrc: "./back6.mp4"
      }));
      // console.log('🎬 受信側に動画背景準備を送信');
    }
    
    // 送信側キャンバスの背景を透明にして動画背景を見せる（描画は保持）
    canvas.style.backgroundColor = 'transparent';
    // ctx.clearRect(0, 0, canvas.width, canvas.height); // 描画を保持するためコメントアウト
    // console.log('🎬 送信側キャンバス透明化 - 動画背景準備完了（描画保持）');
    
  } else if (specialBackgroundState === 'door_shown') {
    // 第2段階: 扉を開いて動画再生開始
    // console.log('🚪 第2段階: 扉開放と動画再生開始');
    specialBackgroundState = 'video_playing';
    
    // 送信側の動画も再生開始
    playSenderVideo();
    
    // 受信側に動画再生開始を通知
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ 
        type: "videoBackground", 
        action: "play",
        videoSrc: "./back6.mp4"
      }));
      // console.log('🎬 受信側に動画再生開始を送信');
    }
    
    // 送信側の表示を更新（キャンバスを透明にして動画背景を見せる）
    ctx.restore();
    // ctx.clearRect(0, 0, canvas.width, canvas.height); // 描画を保持するためコメントアウト
    // 動画背景時はキャンバスを透明にする
    canvas.style.backgroundColor = 'transparent';
    // console.log('🎬 送信側キャンバスを透明化 - 描画と動画が見える状態（描画保持）');
    
    // 動画終了まで待機（back6.mp4の長さに合わせて調整）
    setTimeout(() => {
      // console.log('🎬 動画再生完了 - 最終フレームで停止');
      specialBackgroundState = 'ready';
      
      // 送信側の動画も終了
      stopSenderVideo();
      
      // 受信側に動画終了を通知
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ 
          type: "videoBackground", 
          action: "end"
        }));
        // console.log('🎬 受信側に動画終了を送信');
      }
    }, 15000); // 15秒後（back6.mp4の長さに合わせて調整）
  }
}

function startCountdown() {
  const countdownEl = document.getElementById("countdown");
  
  // 🔸 用紙サイズに応じてカウントダウン時間を調整
  let totalSeconds;
  if (currentPaperSize === "poster") {
    totalSeconds = 8; // ポスター：3秒短縮（11秒→8秒）
  } else if (currentPaperSize === "L") {
    totalSeconds = 9; // L判：2秒短縮（11秒→9秒）
  } else {
    totalSeconds = 11; // A4：従来通り11秒
  }
  
  let seconds = totalSeconds;
  countdownEl.textContent = `お渡しまで：${seconds}秒`;
  
  const timer = setInterval(() => {
    seconds--;
    if (seconds >= 0) {
      countdownEl.textContent = `お渡しまで：${seconds}秒`;
    } else {
      clearInterval(timer);
      countdownEl.textContent = "";
      // ✅ カウントダウン終了後、筆跡のみ削除（背景維持）
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (backgroundImage) {
        drawBackgroundImage(ctx, backgroundImage, canvas);
      }
      
      // 描画コマンドをクリア
      drawingCommands = [];
      // console.log('🧹 カウントダウン終了: 描画コマンドをクリア');
      
      // ✅ 背景の同期送信
      const bgSrc = backgroundImage ? backgroundImage.src : "white";
      socket.send(JSON.stringify({ type: "clear" }));
      socket.send(JSON.stringify({ type: "background", src: bgSrc, writerId: myWriterId }));
    }
  }, 1000);
}

function clearCanvas() {
  // 音楽制御は送信側では無効化（受信側のみで音楽再生）
  
  // console.log('🧹 clearCanvas開始 - 完全データクリア実行');
  // console.log(`🧹 クリア前のhasSentData: ${hasSentData}`);
  // console.log(`🧹 クリア前のotherWritersDataキー数: ${Object.keys(otherWritersData).length}`);
  
  // 送信済みフラグをリセット
  hasSentData = false;
  // console.log('🔓 手動Clear: 送信済みフラグをリセット - 他のwriterデータ受信を再開');
  
  // キャンバスを完全にクリア
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (backgroundImage) {
    drawBackgroundImage(ctx, backgroundImage, canvas);
  }
  
  // 全ての描画データを完全クリア
  otherWritersData = {};
  drawingCommands = [];
  // console.log('🧹 送信側：全描画データを完全クリア');
  // console.log('🧹 drawingCommands配列をクリア:', drawingCommands.length);
  // console.log('🧹 otherWritersData配列をクリア:', Object.keys(otherWritersData).length);
  
  // キャンバスを再描画（背景のみの状態にする）- 遅延実行
  if (window.clearCanvasRedrawTimeout) {
    clearTimeout(window.clearCanvasRedrawTimeout);
  }
  
  window.clearCanvasRedrawTimeout = setTimeout(() => {
    redrawCanvasWithOthers();
    window.clearCanvasRedrawTimeout = null;
  }, 10);
  
  // 全書き手同期のためのクリア命令を送信
  socket.send(JSON.stringify({ 
    type: "globalClear",
    writerId: myWriterId,
    timestamp: Date.now()
  }));
  // console.log('📤 全書き手にクリア指示を送信');
  // console.log('✅ clearCanvas完了');
}

// 自分の描画だけを消去する関数
function clearMyDrawing() {
  console.log('📋 DEBUG: clearMyDrawing実行 - クリア前=' + drawingCommands.length + '件');
  
  // 自分の描画コマンドのみをクリア
  drawingCommands = [];
  console.log('📋 DEBUG: clearMyDrawing完了 - クリア後=' + drawingCommands.length + '件');
  
  // WriterID別描画状態をリセット
  if (writerDrawingStates['self']) {
    writerDrawingStates['self'] = {
      lastPosition: null,
      currentPath: [],
      isDrawing: false
    };
  }
  
  // キャンバスを再描画（背景 + 他の書き手の描画のみ）
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (backgroundImage) {
    drawBackgroundImage(ctx, backgroundImage, canvas);
  }
  
  // 他の書き手の描画を再描画 - 遅延実行
  if (window.clearMyDrawingRedrawTimeout) {
    clearTimeout(window.clearMyDrawingRedrawTimeout);
  }
  
  window.clearMyDrawingRedrawTimeout = setTimeout(() => {
    redrawCanvasWithOthers();
    window.clearMyDrawingRedrawTimeout = null;
  }, 10);
  
  // 受信側に自分の描画クリア指示を送信
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ 
      type: "clearWriter",
      writerId: myWriterId,
      timestamp: Date.now()
    }));
    console.log('📤 受信側に自分の描画クリア指示を送信');
  }
  
  console.log('✅ 自分だけ消去完了');
}

// ペンの太さ設定関数
function setPenThickness(thickness) {
  currentPenThickness = thickness;
  
  // ボタンの選択状態を更新
  document.querySelectorAll('.thickness-btn').forEach(btn => btn.classList.remove('selected'));
  
  // クリックされたボタンを選択状態にする
  document.querySelectorAll('.thickness-btn').forEach(btn => {
    const onClick = btn.getAttribute('onclick');
    if (onClick && onClick.includes(`setPenThickness(${thickness})`)) {
      btn.classList.add('selected');
    }
  });
  
  // console.log(`✏️ ペンの太さを${thickness}に設定`);
  
  // ペンの太さ設定
  
  // 受信側に太さ情報を送信
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ 
      type: "penThickness", 
      thickness: thickness 
    }));
  }
}

// ペンの色設定関数
function setPenColor(color) {
  currentPenColor = color;
  
  // ボタンの選択状態を更新
  document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('selected'));
  
  // クリックされたボタンを選択状態にする
  document.querySelectorAll('.color-btn').forEach(btn => {
    // ボタンのstyle属性から背景色を取得して比較
    const btnStyle = btn.getAttribute('style') || '';
    const btnOnClick = btn.getAttribute('onclick') || '';
    if (btnStyle.includes(`background: ${color}`) || btnStyle.includes(`background:${color}`) ||
        btnOnClick.includes(`setPenColor('${color}')`)) {
      btn.classList.add('selected');
    }
  });
  
  // ペンの色設定
  
  // 受信側に色情報を送信
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ 
      type: "penColor", 
      color: color 
    }));
  }
}

// 16進数カラーをRGBに変換
function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return { r, g, b };
}

// RGBを16進数カラーに変換
function rgbToHex(r, g, b) {
  return "#" + ((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1);
}

// イージング関数（滑らかな変化のため）
function easeInOutSine(x) {
  return -(Math.cos(Math.PI * x) - 1) / 2;
}

// 2つの色の間を補間する（イージング適用）
function interpolateColor(color1, color2, factor) {
  // イージング関数を適用してより滑らかな変化
  const easedFactor = easeInOutSine(factor);
  
  const rgb1 = hexToRgb(color1);
  const rgb2 = hexToRgb(color2);
  
  const r = rgb1.r + easedFactor * (rgb2.r - rgb1.r);
  const g = rgb1.g + easedFactor * (rgb2.g - rgb1.g);
  const b = rgb1.b + easedFactor * (rgb2.b - rgb1.b);
  
  return rgbToHex(r, g, b);
}


// 星エフェクトのON/OFF切り替え
// エフェクトトグル関数はeffects.jsに移動しました

// 🎵 ペン音制御関数（送信側では無効化）
function togglePenSound() {
  penSoundEnabled = false; // 送信側では常に無効
  // 音声は受信側のみで再生
}

function toggleBackgroundDebug() {
  backgroundDebugEnabled = document.getElementById('backgroundDebug').checked;
  // console.log(`🔍 背景デバッグ表示: ${backgroundDebugEnabled ? 'ON' : 'OFF'}`);
  
  // 現在の背景を再描画してデバッグ表示を更新
  if (backgroundImage) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 背景画像を再描画
    const imageAspect = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
    const canvasAspect = canvas.width / canvas.height;
    
    let drawWidth, drawHeight, offsetX, offsetY;
    
    if (imageAspect > canvasAspect) {
      drawWidth = canvas.width;
      drawHeight = drawWidth / imageAspect;
      offsetX = 0;
      offsetY = (canvas.height - drawHeight) / 2;
    } else {
      drawHeight = canvas.height;
      drawWidth = drawHeight * imageAspect;
      offsetX = (canvas.width - drawWidth) / 2;
      offsetY = 0;
    }
    
    // 背景2の特殊処理を削除 - 全背景で統一アスペクト比適用
    
    drawBackgroundImage(ctx, backgroundImage, canvas);
    
    // デバッグ表示が有効な場合のみ視覚的な表示を追加
    if (backgroundDebugEnabled) {
      // デバッグ表示用に計算された値を使用
      const imageAspectDebug = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
      const canvasAspectDebug = canvas.width / canvas.height;
      let debugDrawWidth, debugDrawHeight, debugOffsetX, debugOffsetY;
      
      if (imageAspectDebug > canvasAspectDebug) {
        debugDrawWidth = canvas.width;
        debugDrawHeight = canvas.width / imageAspectDebug;
        debugOffsetX = 0;
        debugOffsetY = (canvas.height - debugDrawHeight) / 2;
      } else {
        debugDrawHeight = canvas.height;
        debugDrawWidth = canvas.height * imageAspectDebug;
        debugOffsetX = (canvas.width - debugDrawWidth) / 2;
        debugOffsetY = 0;
      }
      
      addBackgroundDebugVisuals(debugOffsetX, debugOffsetY, debugDrawWidth, debugDrawHeight);
    }
  }
}

function addBackgroundDebugVisuals(offsetX, offsetY, drawWidth, drawHeight) {
  ctx.save();
  
  // 背景画像の境界線
  ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.strokeRect(offsetX, offsetY, drawWidth, drawHeight);
  
  // キャンバス中心点（緑）
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
  ctx.beginPath();
  ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
  ctx.fill();
  
  // 背景画像中心点（青）
  const bgCenterX = offsetX + drawWidth / 2;
  const bgCenterY = offsetY + drawHeight / 2;
  ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
  ctx.beginPath();
  ctx.arc(bgCenterX, bgCenterY, 5, 0, 2 * Math.PI);
  ctx.fill();
  
  ctx.restore();
}

function initDrawingAudio() {
  if (!drawingAudio) {
    drawingAudio = new Audio('./draw.mp3');
    drawingAudio.loop = true; // ループ再生
    drawingAudio.volume = 0.7; // ボリュームを70%に設定
    // 描画音楽初期化
  }
}

function startDrawingMusic() {
  if (!penSoundEnabled) return; // ペン音が無効の場合は何もしない
  
  initDrawingAudio();
  
  if (drawingAudio.paused) {
    drawingAudio.play().then(() => {
      // 描画音楽開始
    }).catch(e => {
      // 描画音楽再生エラー
    });
  }
  
  isDrawingActive = true;
  
  // 既存のタイマーをクリア
  if (drawingInactiveTimer) {
    clearTimeout(drawingInactiveTimer);
    drawingInactiveTimer = null;
  }
}

function pauseDrawingMusic() {
  if (drawingAudio && !drawingAudio.paused) {
    drawingAudio.pause();
    // 描画音楽一時停止
  }
  isDrawingActive = false;
}

function stopDrawingMusic() {
  if (drawingAudio) {
    drawingAudio.pause();
    drawingAudio.currentTime = 0; // 最初に戻す
    // 描画音楽停止
  }
  isDrawingActive = false;
  
  // タイマーをクリア
  if (drawingInactiveTimer) {
    clearTimeout(drawingInactiveTimer);
    drawingInactiveTimer = null;
  }
}

function handleDrawingActivity() {
  if (!penSoundEnabled) return; // ペン音が無効の場合は何もしない
  
  startDrawingMusic();
  
  // 既存のタイマーをクリア
  if (drawingInactiveTimer) {
    clearTimeout(drawingInactiveTimer);
  }
  
  // 新しいタイマーを設定（描画停止を検知）
  drawingInactiveTimer = setTimeout(() => {
    pauseDrawingMusic();
    // console.log('🎵 描画が停止したため音楽を一時停止');
  }, DRAWING_PAUSE_DELAY);
}

// 描画用ハートを生成する関数
// 描画エフェクト関数群はeffects.jsに移動しました
// createDrawingHeart, createSenderStar, createFairyDust, createStar

// 特殊エフェクト関数群はspecial-effects.jsに移動しました
// addSenderFireworkAnimations, createFireworks, createExplosion, createConfetti// 🎨 WriterID別描画状態ヘルパー関数
function getWriterDrawingState(writerId) {
  if (!writerId) writerId = 'self'; // 自分の描画の場合
  
  if (!writerDrawingStates[writerId]) {
    writerDrawingStates[writerId] = {
      lastPosition: null,
      currentPath: [],
      isDrawing: false
    };
  }
  return writerDrawingStates[writerId];
}

function resetWriterDrawingState(writerId) {
  if (!writerId) writerId = 'self';
  writerDrawingStates[writerId] = {
    lastPosition: null,
    currentPath: [],
    isDrawing: false
  };
}

// 🎨 WriterID別連続描画関数
function drawContinuousLineForWriter(x, y, writerId = 'self') {
  const writerState = getWriterDrawingState(writerId);
  
  if (!writerState.lastPosition) {
    // 描画開始点 - 他WriterIDとの状態混在を完全に防止
    ctx.beginPath(); // 重要：他のWriterの未完了パスをクリア
    ctx.moveTo(x, y);
    writerState.lastPosition = { x, y };
    writerState.currentPath = [{ x, y }];
    return;
  }
  
  // 距離が近すぎる場合はスキップ（パフォーマンス向上）
  const lastPos = writerState.lastPosition;
  const distance = Math.sqrt(Math.pow(x - lastPos.x, 2) + Math.pow(y - lastPos.y, 2));
  if (distance < 1) {
    return; // 1ピクセル以下の移動は無視
  }
  
  // スムージング: quadratic curve で滑らかな曲線を描画
  if (writerState.currentPath && writerState.currentPath.length >= 2) {
    const prev2 = writerState.currentPath[writerState.currentPath.length - 2];
    const prev1 = writerState.currentPath[writerState.currentPath.length - 1];
    
    // 中点を制御点として使用
    const midX = (prev1.x + x) / 2;
    const midY = (prev1.y + y) / 2;
    
    ctx.quadraticCurveTo(prev1.x, prev1.y, midX, midY);
    ctx.stroke();
  } else {
    // 最初の数点は直線
    ctx.lineTo(x, y);
    ctx.stroke();
  }
  
  // 現在の点をパスに追加
  writerState.currentPath.push({ x, y });
  
  // パスの長さを制限（メモリ効率化）
  if (writerState.currentPath.length > 3) {
    writerState.currentPath.shift();
  }
  
  writerState.lastPosition = { x, y };
}

// 🎨 連続的な描画関数（一般的なペイントツールスタイル）- レガシー互換用
function drawContinuousLine(x, y) {
  // 新しいWriterID別描画システムを使用
  drawContinuousLineForWriter(x, y, 'self');
  // レガシー変数も更新（後方互換性のため）
  lastPosition = { x, y };
}

// interpolatePoints関数を削除（パフォーマンス改善）

// console.log('🎯 mousedownイベントリスナーをcanvasに追加中...');
// console.log('🎯 canvas要素の状態:', canvas);
// console.log('🎯 canvas要素のタグ名:', canvas ? canvas.tagName : 'null');

// 確実にイベントリスナーを追加するため、DOMが完全に読み込まれてから実行
document.addEventListener('DOMContentLoaded', function() {
  // console.log('🎯 DOMContentLoaded - イベントリスナーを再度追加');
  const canvasElement = document.getElementById('drawCanvas');
  // console.log('🎯 再取得したcanvas要素:', canvasElement);
  
  if (canvasElement) {
    // すべてのマウスイベントをテスト
    canvasElement.addEventListener("mousedown", (e) => {
      // console.log('🖱️ DOMContentLoaded後のmousedownイベント発生');
      // console.log('🖱️ マウス座標:', e.offsetX, e.offsetY);
      // console.log('🖱️ イベントターゲット:', e.target);
    });
    
    // イベントテストを拡張
    let isMousePressed = false;
    let lastPos = null;
    
    // mousemoveイベントでマウスボタンの状態を判定する方式
    canvasElement.addEventListener('mousemove', (e) => {
      const x = e.offsetX;
      const y = e.offsetY;
      const isCurrentlyPressed = e.buttons === 1; // 左ボタンが押されている
      
      // デバッグ用：buttons値を詳しく表示
      // if (e.buttons !== 0) {
      //   console.log(`🖱️ mousemove（ボタン押下中） - 座標: ${x}, ${y}, buttons: ${e.buttons}`);
      // }
      
      // マウスボタンが押された瞬間（描画開始）
      if (isCurrentlyPressed && !isMousePressed) {
        // console.log('🖱️ マウスボタン押下検出 - 描画開始');
        isMousePressed = true;
        drawing = true;
        lastPos = { x, y };
        
        // 描画設定を初期化
        ctx.strokeStyle = currentPenColor || 'black';
        ctx.lineWidth = currentPenThickness || 8;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
        ctx.globalAlpha = 1.0;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // 描画開始時に点を描画
        ctx.lineTo(x + 1, y + 1);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // console.log('🖱️ 描画開始点設定:', x, y);
      }
      // マウスボタンが離された瞬間（描画終了）
      else if (!isCurrentlyPressed && isMousePressed) {
        // console.log('🖱️ マウスボタン離脱検出 - 描画終了');
        isMousePressed = false;
        drawing = false;
        lastPos = null;
      }
      // マウスボタンが押されている間（描画継続）
      else if (isCurrentlyPressed && isMousePressed && drawing) {
        // console.log('🖱️ 描画継続中:', x, y);
        
        if (lastPos) {
          // 前の点から現在の点まで線を描画
          ctx.beginPath();
          ctx.moveTo(lastPos.x, lastPos.y);
          ctx.lineTo(x, y);
          ctx.stroke();
        }
        
        lastPos = { x, y };
      }
    });
    
    // 標準的なペイントツール方式の描画システム
    // isPaintDrawing、lastPaintPos、getBackgroundArea、isWithinBackgroundAreaはグローバルで定義済み
    
    // 以下の関数は削除（グローバルで定義済み）
    /* function getBackgroundArea() {
      if (!backgroundImage) {
        // 背景画像がない場合は全範囲を許可
        // console.log('🖼️ 背景画像なし - 全範囲を許可'); // 軽量化
        return {
          x: 0,
          y: 0,
          width: canvas.width,
          height: canvas.height
        };
      }
      
      // drawBackgroundImage関数と同じ計算ロジック（2倍拡大を含む）
      const canvasRatio = canvas.width / canvas.height;
      const imageRatio = backgroundImage.width / backgroundImage.height;
      
      let baseWidth, baseHeight;
      
      // 基本サイズを計算（contain方式）
      if (imageRatio > canvasRatio) {
        // 画像の方が横長
        baseWidth = canvas.width;
        baseHeight = canvas.width / imageRatio;
      } else {
        // 画像の方が縦長
        baseHeight = canvas.height;
        baseWidth = canvas.height * imageRatio;
      }
      
      // 背景画像と描画エリアを同じサイズに
      const scale = 1.0;
      const drawWidth = baseWidth * scale;
      const drawHeight = baseHeight * scale;
      
      // 中央に配置するためのオフセット
      const offsetX = (canvas.width - drawWidth) / 2;
      const offsetY = (canvas.height - drawHeight) / 2;
      
      console.log('🖼️ 背景画像範囲計算:', {
        canvasSize: { width: canvas.width, height: canvas.height },
        imageSize: { width: backgroundImage.width, height: backgroundImage.height },
        baseSize: { width: baseWidth, height: baseHeight },
        scale: scale,
        drawArea: { x: offsetX, y: offsetY, width: drawWidth, height: drawHeight }
      });
      
      return {
        x: offsetX,
        y: offsetY,
        width: drawWidth,
        height: drawHeight
      };
    }
    
    // 座標が背景画像の範囲内かチェックする関数
    function isWithinBackgroundArea(x, y) {
      // 背景画像範囲チェックを再有効化して詳細ログ出力
      const bgArea = getBackgroundArea();
      
      const withinX = x >= bgArea.x && x <= bgArea.x + bgArea.width;
      const withinY = y >= bgArea.y && y <= bgArea.y + bgArea.height;
      const isWithin = withinX && withinY;
      
      console.log('🖼️ 背景画像範囲チェック詳細:', {
        clickX: x,
        clickY: y,
        bgX: bgArea.x,
        bgY: bgArea.y,
        bgWidth: bgArea.width,
        bgHeight: bgArea.height,
        withinX: withinX,
        withinY: withinY,
        結果: isWithin ? '✅ 範囲内' : '❌ 範囲外'
      });
      
      return isWithin;
    } */
      
      /* オリジナルのチェックロジック（参考用）
      const bgArea = getBackgroundArea();
      
      console.log('🖼️ 背景画像範囲チェック:', {
        clickX: x,
        clickY: y,
        bgX: bgArea.x,
        bgY: bgArea.y,
        bgWidth: bgArea.width,
        bgHeight: bgArea.height,
        withinX: x >= bgArea.x && x <= bgArea.x + bgArea.width,
        withinY: y >= bgArea.y && y <= bgArea.y + bgArea.height
      });
      
      return x >= bgArea.x && 
             x <= bgArea.x + bgArea.width && 
             y >= bgArea.y && 
             y <= bgArea.y + bgArea.height;
      */
    
    // PointerEventsを使用（より確実なイベント処理）
    if ('PointerEvent' in window) {
      // console.log('🖱️ PointerEventsを使用');
      
      canvasElement.addEventListener('pointerdown', (e) => {
        // console.log('🖱️ pointerdown - 描画開始');
        
        // 正確な座標を取得（canvas内の相対座標）
        const rect = canvasElement.getBoundingClientRect();
        const scaleX = canvasElement.width / rect.width;
        const scaleY = canvasElement.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        // console.log('🖱️ 座標詳細:', {
        //   clientX: e.clientX,
        //   clientY: e.clientY,
        //   rectLeft: rect.left,
        //   rectTop: rect.top,
        //   scaleX: scaleX,
        //   scaleY: scaleY,
        //   finalX: x,
        //   finalY: y
        // });
        
        // 背景画像の範囲内かチェック
        if (!isWithinBackgroundArea(x, y)) {
          console.log('🖱️ 背景画像範囲外のためスキップ');
          return;
        }
        
        isPaintDrawing = true;
        lastPaintPos = { x, y };
        
        // 描画設定
        ctx.strokeStyle = currentPenColor || 'black';
        ctx.lineWidth = currentPenThickness || 8;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // 描画開始点
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // 開始点に小さな点を描画
        ctx.lineTo(x + 0.1, y + 0.1);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // 自分の描画コマンドとして保存
        const startCmd = {
          type: "start",
          x: x,
          y: y,
          thickness: currentPenThickness,
          color: currentPenColor === 'black' ? '#000' : currentPenColor
        };
        drawingCommands.push(startCmd);
        // console.log(`📋 DEBUG: start保存 - 配列数=${drawingCommands.length}件`); // 軽量化

        // WebSocketで受信側に描画開始を送信
        const startMsg = {
          type: "start",
          x: x,
          y: y,
          thickness: currentPenThickness,
          color: currentPenColor,
          writerId: myWriterId,
          timestamp: Date.now()
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify(startMsg));
          const isValidCoord = x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height;
          console.log("📤 PC描画開始データ送信:", {
            type: startMsg.type,
            writerId: startMsg.writerId,
            x: Math.round(x),
            y: Math.round(y),
            canvasSize: `${canvas.width}x${canvas.height}`,
            座標妥当性: isValidCoord
          });
        }
      });
      
      canvasElement.addEventListener('pointermove', (e) => {
        if (!isPaintDrawing || !lastPaintPos) return;
        
        // 正確な座標を取得
        const rect = canvasElement.getBoundingClientRect();
        const scaleX = canvasElement.width / rect.width;
        const scaleY = canvasElement.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        // console.log('🖱️ pointermove - 描画中:', x, y); // 軽量化
        
        // 背景画像の範囲内かチェック
        if (!isWithinBackgroundArea(x, y)) {
          console.log('🖱️ 背景画像範囲外 - 描画中断');
          isPaintDrawing = false;
          lastPaintPos = null;
          return;
        }
        
        // 線を描画
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // 自分の描画コマンドとして保存
        const actualColor = currentPenColor === 'white-red-border' ? '#ffffff' : 
                           (currentPenColor === 'black' ? '#000' : 
                           (currentPenColor === 'white' ? '#fff' : 
                           (currentPenColor === 'green' ? '#008000' : 
                           (currentPenColor === 'pink' ? '#ff69b4' : currentPenColor))));
        const drawCmd = {
          type: "draw",
          x: x,
          y: y,
          thickness: currentPenThickness,
          color: actualColor
        };
        drawingCommands.push(drawCmd);
        // console.log(`📋 DEBUG: draw保存 - 配列数=${drawingCommands.length}件`); // 軽量化
        
        // WebSocketで受信側に描画継続データを送信
        const drawMsg = {
          type: "draw",
          x: x,
          y: y,
          thickness: currentPenThickness,
          color: currentPenColor,
          writerId: myWriterId,
          timestamp: Date.now(),
          starEffect: starEffectEnabled,
          fairyDustEffect: fairyDustEffectEnabled,
          canvasSize: {
            width: canvas.width,
            height: canvas.height
          }
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify(drawMsg));
          // 頻度を減らしてログ出力（10回に1回）
          if (Math.random() < 0.1) {
            console.log("📤 PC描画継続データ送信:", {
              writerId: drawMsg.writerId,
              x: Math.round(x),
              y: Math.round(y)
            });
          }
        }
        
        // 書き手側エフェクト：キャンバス座標をページ座標に変換
        const pageX = rect.left + x;
        const pageY = rect.top + y;
        // 星エフェクトが有効な場合は星を生成（50%の頻度）
        if (starEffectEnabled && Math.random() < 0.5) {
          createSenderStar(pageX, pageY);
        }

        // 妖精の粉エフェクトが有効な場合は妖精の粉を生成（15回に1回の頻度）
        if (fairyDustEffectEnabled && Math.random() < 0.067) {
          createFairyDust(pageX, pageY);
        }
        
        // ハートエフェクトが有効な場合はハートを生成（20回に1回の頻度）
        if (heartEffectEnabled && Math.random() < 0.05) {
          createDrawingHeart(pageX, pageY);
        }
        
        lastPaintPos = { x, y };
      });
      
      canvasElement.addEventListener('pointerup', (e) => {
        // console.log('🖱️ pointerup - 描画終了'); // 軽量化
        isPaintDrawing = false;
        lastPaintPos = null;
      });
      
    } else {
      console.log('🖱️ 従来のマウスイベントを使用');
      
      // 従来のマウスイベント（フォールバック）
      canvasElement.addEventListener('mousedown', (e) => {
        console.log('🖱️ mousedown - 描画開始');
        
        // 正確な座標を取得
        const rect = canvasElement.getBoundingClientRect();
        const scaleX = canvasElement.width / rect.width;
        const scaleY = canvasElement.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        // 背景画像の範囲内かチェック
        if (!isWithinBackgroundArea(x, y)) {
          console.log('🖱️ 背景画像範囲外のためスキップ');
          return;
        }
        
        isPaintDrawing = true;
        lastPaintPos = { x, y };
        
        // 描画設定
        ctx.strokeStyle = currentPenColor || 'black';
        ctx.lineWidth = currentPenThickness || 8;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // 描画開始点
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // WebSocketで受信側に描画開始を送信
        const startMsg = {
          type: "start",
          x: x,
          y: y,
          thickness: currentPenThickness,
          color: currentPenColor,
          writerId: myWriterId,
          timestamp: Date.now()
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify(startMsg));
          console.log("📤 PC描画開始データ送信(mouse):", startMsg);
        }
        
        e.preventDefault();
      });
      
      canvasElement.addEventListener('mousemove', (e) => {
        if (!isPaintDrawing || !lastPaintPos) return;
        
        // 正確な座標を取得
        const rect = canvasElement.getBoundingClientRect();
        const scaleX = canvasElement.width / rect.width;
        const scaleY = canvasElement.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        // console.log('🖱️ mousemove - 描画中:', x, y); // 軽量化
        
        // 背景画像の範囲内かチェック
        if (!isWithinBackgroundArea(x, y)) {
          console.log('🖱️ 背景画像範囲外 - 描画中断');
          isPaintDrawing = false;
          lastPaintPos = null;
          return;
        }
        
        // 線を描画
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // WebSocketで受信側に描画継続データを送信
        const drawMsg = {
          type: "draw",
          x: x,
          y: y,
          thickness: currentPenThickness,
          color: currentPenColor,
          writerId: myWriterId,
          timestamp: Date.now(),
          starEffect: starEffectEnabled,
          fairyDustEffect: fairyDustEffectEnabled,
          canvasSize: {
            width: canvas.width,
            height: canvas.height
          }
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify(drawMsg));
          console.log("📤 PC描画継続データ送信(mouse):", x, y);
        }
        
        lastPaintPos = { x, y };
      });
      
      canvasElement.addEventListener('mouseup', (e) => {
        console.log('🖱️ mouseup - 描画終了');
        isPaintDrawing = false;
        lastPaintPos = null;
      });
    }
    
    // mouseleaveで描画を終了（一般的なペイントツールの動作）
    canvasElement.addEventListener("mouseleave", (e) => {
      console.log('🖱️ mouseleave - 描画終了');
      if (isPaintDrawing) {
        isPaintDrawing = false;
        lastPaintPos = null;
      }
    });
    
    // 右クリックで描画を中断
    canvasElement.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      console.log('🖱️ 右クリック - 描画中断');
      if (isPaintDrawing) {
        isPaintDrawing = false;
        lastPaintPos = null;
      }
    });
    
    
    // タッチイベントもテスト（PCでも発生する場合がある）
    canvasElement.addEventListener("touchstart", (e) => {
      console.log('📱 touchstartイベント発生');
      e.preventDefault();
    });
  }
});

canvas.addEventListener("mousedown", (e) => {
  console.log('🖱️ mousedownイベント発生');
  console.log('🎯 canvas要素:', canvas);
  console.log('🎯 ctx:', ctx);
  console.log('🎯 drawing変数:', drawing);
  // 常に新しい描画を可能にする（hasSentDataチェックを削除）
  
  drawing = true;
  const x = e.offsetX;
  const y = e.offsetY;
  
  // ベジェ曲線用の点履歴をリセット
  pointHistory = [{ x, y }];
  
  console.log(`🖱️ マウス開始座標: offsetX=${x}, offsetY=${y}`);
  
  // 描画設定を初期化（前の描画設定をクリア）
  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';
  ctx.globalAlpha = 1.0;
  
  // WriterID別描画状態をリセット
  resetWriterDrawingState('self');
  const selfState = getWriterDrawingState('self');
  selfState.lastPosition = { x, y };
  selfState.currentPath = [{ x, y }];
  selfState.isDrawing = true;
  
  // 音楽制御は送信側では無効化（受信側のみで音楽再生）
  
  // Canvas状態を完全に初期化（他WriterIDとの状態混在を防止）
  ctx.beginPath(); // 重要：他のWriterの未完了パスを完全にクリア
  ctx.setTransform(1, 0, 0, 1, 0, 0); // 変換行列をリセット
  ctx.globalCompositeOperation = 'source-over'; // 合成モードをリセット
  ctx.moveTo(x, y);
  
  // 線の品質を向上させる設定
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  
  // レガシー変数も更新（後方互換性のため）
  lastPosition = { x, y }; // 初期位置を記録
  currentPath = [{ x, y }]; // 新しいパスを開始
  
  // 描画コマンドを記録
  const startCmd = {
    type: "start",
    x: x,
    y: y,
    thickness: currentPenThickness,
    color: currentPenColor === 'black' ? '#000' : currentPenColor
  };
  drawingCommands.push(startCmd);
  console.log(`📋 DEBUG: start保存 - 配列数=${drawingCommands.length}件`);
  
  // Writer IDが未設定の場合は送信しない
  if (!myWriterId) {
    console.warn("⚠️ Writer ID未設定のため描画データを送信しません");
    if (confirm("Writer IDが設定されていません。\n\n🔄 自動で再要求しますか？\n\n「OK」= 自動要求\n「キャンセル」= 手動で右上「ID確認」ボタン")) {
      requestWriterId();
    }
    return;
  }
  
  const startMsg = { 
    type: "start", 
    writerId: myWriterId, // Writer ID を追加
    x, 
    y,
    thickness: currentPenThickness,
    color: currentPenColor,
    starEffect: starEffectEnabled,
    fairyDustEffect: fairyDustEffectEnabled,
    heartEffect: heartEffectEnabled,
    canvasSize: { width: canvas.width, height: canvas.height }
  };
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify(startMsg));
    // console.log("📤 送信 start:", startMsg);
  } else {
    console.error("❌ WebSocket接続なし - start送信失敗");
  }
  
  // 書き手側エフェクト：キャンバス座標をページ座標に変換
  const rect = canvas.getBoundingClientRect();
  const pageX = rect.left + x;
  const pageY = rect.top + y;

  // 星エフェクトが有効な場合は星を生成
  if (starEffectEnabled) {
    createSenderStar(pageX, pageY);
  }
  
  // 妖精の粉エフェクトが有効な場合は妖精の粉を生成
  if (fairyDustEffectEnabled) {
    createFairyDust(pageX, pageY);
  }
});

canvas.addEventListener("mouseup", () => {
  drawing = false;
  
  // ベジェ曲線用の点履歴をクリア
  pointHistory = [];
  
  // WriterID別描画状態を更新
  const selfState = getWriterDrawingState('self');
  selfState.isDrawing = false;
  
  // 白地赤縁の場合は赤い縁を追加
  if (currentPenColor === 'white-red-border' && currentPath.length > 1) {
    // 赤い太線を描画（グラデーション効果付き）
    ctx.save();
    
    // 外側の薄い赤（最も太い）
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    ctx.lineWidth = currentPenThickness + 10;
    ctx.globalAlpha = 0.2;
    ctx.strokeStyle = '#ffccdd';
    // ctx.shadowBlur = 15; // パフォーマンス改善のため無効化
    ctx.shadowColor = '#ffccdd';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    
    // 中間の赤
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    ctx.lineWidth = currentPenThickness + 8;
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = '#ffaacc';
    // ctx.shadowBlur = 10; // パフォーマンス改善のため無効化
    ctx.shadowColor = '#ffaacc';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    
    // 内側の濃い赤（コア）
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    ctx.lineWidth = currentPenThickness + 6;
    ctx.globalAlpha = 0.8;
    ctx.strokeStyle = '#ff88bb';
    // ctx.shadowBlur = 6; // パフォーマンス改善のため無効化
    ctx.shadowColor = '#ff88bb';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    
    ctx.restore();
    
    // 元の白い線を上に再描画（グロー効果付き）
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    ctx.lineWidth = Math.max(1, currentPenThickness - 3);
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = '#ffffff';
    // ctx.shadowBlur = 10; // パフォーマンス改善のため無効化
    ctx.shadowColor = '#ffffff';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    ctx.restore();
  }
  
  // パスをクリア
  currentPath = [];
  
  // 🔸 不要な"end"メッセージを削除（受信側で処理していないため）
});

canvas.addEventListener("mousemove", (e) => {
  const mouseMoveStart = performance.now();
  if (!drawing) return;
  
  // 🚀 非侵入的パフォーマンス最適化: スロットリングチェック
  if (!performanceOptimizer.shouldProcessMouseEvent()) {
    return; // 16ms以内の連続イベントをスキップ
  }
  
  // 常に描画継続を可能にする（hasSentDataチェックを削除）
  
  const x = e.offsetX;
  const y = e.offsetY;
  
  // 音楽制御は送信側では無効化（受信側のみで音楽再生）
  
  let actualColor;
  
  // ベジェ曲線による滑らかな描画
  if (lastPosition) {
    // ペン設定
    if (currentPenColor === 'white-red-border') {
      actualColor = 'white-red-border';
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = Math.max(1, currentPenThickness - 3);
      ctx.strokeStyle = '#ffffff';
      ctx.shadowColor = '#ffffff';
    } else {
      actualColor = currentPenColor === 'black' ? '#000' : (currentPenColor === 'white' ? '#fff' : (currentPenColor === 'green' ? '#008000' : (currentPenColor === 'pink' ? '#ff69b4' : currentPenColor)));
      ctx.lineWidth = currentPenThickness;
      ctx.strokeStyle = actualColor;
      ctx.shadowBlur = 0;
      ctx.shadowColor = 'transparent';
      ctx.globalAlpha = 1.0;
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // 点履歴に現在の点を追加
    pointHistory.push({ x, y });
    if (pointHistory.length > MAX_POINT_HISTORY) {
      pointHistory.shift();
    }
    
    // 点が2つ以上ある場合に描画
    if (pointHistory.length >= 2) {
      const len = pointHistory.length;
      
      if (len === 2) {
        // 2点の場合は直線
        ctx.beginPath();
        ctx.moveTo(pointHistory[0].x, pointHistory[0].y);
        ctx.lineTo(pointHistory[1].x, pointHistory[1].y);
        ctx.stroke();
      } else {
        // 3点の場合はベジェ曲線
        const p0 = pointHistory[len - 3];
        const p1 = pointHistory[len - 2];
        const p2 = pointHistory[len - 1];
        
        // 中点を計算して滑らかな曲線を描画
        const midPoint1 = {
          x: (p0.x + p1.x) / 2,
          y: (p0.y + p1.y) / 2
        };
        const midPoint2 = {
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2
        };
        
        ctx.beginPath();
        ctx.moveTo(midPoint1.x, midPoint1.y);
        ctx.quadraticCurveTo(p1.x, p1.y, midPoint2.x, midPoint2.y);
        ctx.stroke();
      }
    }
    
    currentPath.push({ x, y });
    ctx.globalAlpha = 1.0;
  }
  
  // 描画コマンドを記録
  const drawCmd = {
    type: "draw",
    x: x,
    y: y,
    thickness: currentPenThickness,
    color: actualColor
  };
  drawingCommands.push(drawCmd);
  // console.log(`📋 DEBUG: draw保存 - 配列数=${drawingCommands.length}件`); // 軽量化
  
  // 現在の位置を記録
  lastPosition = { x, y };
  
  // Writer IDが未設定の場合は送信しない
  if (!myWriterId) {
    return;
  }
  
  const drawMsg = { 
    type: "draw", 
    writerId: myWriterId, // Writer ID を追加
    x, 
    y,
    thickness: currentPenThickness,
    color: currentPenColor,
    starEffect: starEffectEnabled,
    fairyDustEffect: fairyDustEffectEnabled,
    heartEffect: heartEffectEnabled,
    canvasSize: { width: canvas.width, height: canvas.height }
  };
  if (socket && socket.readyState === WebSocket.OPEN) {
    const wsStart = performance.now();
    socket.send(JSON.stringify(drawMsg));
    const wsEnd = performance.now();
    if (wsEnd - wsStart > 1) {
      console.log(`📡 WebSocket send slow: ${(wsEnd - wsStart).toFixed(2)}ms`);
    }
  }
  // console.log("📤 送信 draw:", drawMsg, `myWriterId=${myWriterId}`); // パフォーマンスのためコメントアウト
  
  
  // 書き手側エフェクト：キャンバス座標をページ座標に変換
  const rect = canvas.getBoundingClientRect();
  const pageX = rect.left + x;
  const pageY = rect.top + y;

  // 🚀 非侵入的パフォーマンス最適化: エフェクトを遺延実行
  if (starEffectEnabled) {
    performanceOptimizer.scheduleEffect(() => createSenderStar(pageX, pageY));
  }
  if (fairyDustEffectEnabled) {
    performanceOptimizer.scheduleEffect(() => createFairyDust(pageX, pageY));
  }
  if (heartEffectEnabled) {
    performanceOptimizer.scheduleEffect(() => createDrawingHeart(pageX, pageY));
  }
  
  const mouseMoveEnd = performance.now();
  if (mouseMoveEnd - mouseMoveStart > 10) {
    console.log(`🖱️ mousemove slow: ${(mouseMoveEnd - mouseMoveStart).toFixed(2)}ms`);
  }
});

// 🔸 タブレット対応：タッチイベント（PC用描画処理と完全統一）
canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  console.log('📱 DEBUG: touchstart - PC用処理と統一');
  
  drawing = true;
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (touch.clientX - rect.left) * scaleX;
  const y = (touch.clientY - rect.top) * scaleY;
  
  // ベジェ曲線用の点履歴をリセット
  pointHistory = [{ x, y }];
  
  // 背景画像の範囲内かチェック（PC用と同じ処理）
  if (!isWithinBackgroundArea(x, y)) {
    console.log('📱 背景画像範囲外 - 描画中断');
    drawing = false;
    return;
  }
  
  // PC用と完全同じ描画処理をコピー
  isPaintDrawing = true;
  lastPaintPos = { x, y };
  
  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';
  ctx.globalAlpha = 1.0;
  
  // PC用と完全同じ描画処理
  ctx.beginPath();
  
  let actualColor = currentPenColor === 'black' ? '#000' : (currentPenColor === 'white' ? '#fff' : (currentPenColor === 'green' ? '#008000' : (currentPenColor === 'pink' ? '#ff69b4' : currentPenColor)));
  
  if (currentPenColor === 'white-red-border') {
    // 白地赤縁の特別処理（PC版と同じ）
    ctx.beginPath();
    ctx.globalAlpha = 0.3;
    ctx.lineWidth = currentPenThickness + 8;
    ctx.strokeStyle = '#ffccdd';
    ctx.shadowColor = '#ffccdd';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.moveTo(x, y);
    ctx.lineTo(x + 0.1, y + 0.1);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.globalAlpha = 0.8;
    ctx.lineWidth = currentPenThickness + 6;
    ctx.strokeStyle = '#ff88bb';
    ctx.shadowColor = '#ff88bb';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.moveTo(x, y);
    ctx.lineTo(x + 0.1, y + 0.1);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.globalAlpha = 0.9;
    ctx.lineWidth = Math.max(1, currentPenThickness - 3);
    ctx.strokeStyle = '#ffffff';
    ctx.shadowColor = '#ffffff';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.moveTo(x, y);
    ctx.lineTo(x + 0.1, y + 0.1);
    ctx.stroke();
    
    ctx.globalAlpha = 1.0;
  } else {
    // 通常の色の描画（PC版と同じ）
    ctx.lineWidth = currentPenThickness;
    ctx.strokeStyle = actualColor;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.moveTo(x, y);
    
    ctx.lineTo(x + 0.1, y + 0.1);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }
  
  // 自分の描画コマンドとして保存（PC版と同じ）
  const startCmd = {
    type: "start",
    x: x,
    y: y,
    thickness: currentPenThickness,
    color: currentPenColor === 'black' ? '#000' : currentPenColor
  };
  drawingCommands.push(startCmd);
  console.log(`📋 DEBUG: start保存 - 配列数=${drawingCommands.length}件`);
  
  // WebSocket送信（PC版と同じ）
  const startMsg = {
    type: "start",
    x: x,
    y: y,
    thickness: currentPenThickness,
    color: currentPenColor,
    writerId: myWriterId,
    timestamp: Date.now()
  };
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify(startMsg));
    const isValidCoord = x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height;
    /* console.log("📤 タブレット描画開始データ送信:", {
      type: startMsg.type,
      writerId: startMsg.writerId,
      x: Math.round(x),
      y: Math.round(y),
      canvasSize: `${canvas.width}x${canvas.height}`,
      座標妥当性: isValidCoord
    }); */ // 軽量化
  }
  
  // 書き手側エフェクト：キャンバス座標をページ座標に変換（既存のrect変数を再利用）
  const pageX = rect.left + x;
  const pageY = rect.top + y;

  // 星エフェクトが有効な場合は星を生成
  if (starEffectEnabled) {
    createSenderStar(pageX, pageY);
  }
  
  // 妖精の粉エフェクトが有効な場合は妖精の粉を生成
  if (fairyDustEffectEnabled) {
    createFairyDust(pageX, pageY);
  }
});

canvas.addEventListener("touchend", (e) => {
  e.preventDefault();
  // console.log('📱 DEBUG: touchend - PC用処理と統一'); // 軽量化
  
  // PC用と同じ処理に統一
  drawing = false;
  
  // ベジェ曲線用の点履歴をクリア
  pointHistory = [];
  isPaintDrawing = false;
  lastPaintPos = null;
  
  // 白地赤縁の場合は赤い縁を追加
  if (currentPenColor === 'white-red-border' && currentPath.length > 1) {
    // 赤い太線を描画（グラデーション効果付き）
    ctx.save();
    
    // 外側の薄い赤（最も太い）
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    ctx.lineWidth = currentPenThickness + 10;
    ctx.globalAlpha = 0.2;
    ctx.strokeStyle = '#ffccdd';
    // ctx.shadowBlur = 15; // パフォーマンス改善のため無効化
    ctx.shadowColor = '#ffccdd';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    
    // 中間の赤
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    ctx.lineWidth = currentPenThickness + 8;
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = '#ffaacc';
    // ctx.shadowBlur = 10; // パフォーマンス改善のため無効化
    ctx.shadowColor = '#ffaacc';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    
    // 内側の濃い赤（コア）
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    ctx.lineWidth = currentPenThickness + 6;
    ctx.globalAlpha = 0.8;
    ctx.strokeStyle = '#ff88bb';
    // ctx.shadowBlur = 6; // パフォーマンス改善のため無効化
    ctx.shadowColor = '#ff88bb';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    
    ctx.restore();
    
    // 元の白い線を上に再描画（グロー効果付き）
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    ctx.lineWidth = Math.max(1, currentPenThickness - 3);
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = '#ffffff';
    // ctx.shadowBlur = 10; // パフォーマンス改善のため無効化
    ctx.shadowColor = '#ffffff';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    for (let i = 1; i < currentPath.length; i++) {
      ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    ctx.restore();
  }
  
  // パスをクリア
  currentPath = [];
});

// タッチ描画のスムージング用変数
let touchAnimationFrame = null;
let pendingTouchData = null;

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if (!isPaintDrawing || !lastPaintPos) return;
  
  // 🚀 非侵入的パフォーマンス最適化: タッチイベントスロットリング
  if (!performanceOptimizer.shouldProcessTouchEvent()) {
    return; // 16ms以内の連続タッチをスキップ
  }
  
  // デバッグログを減らす（パフォーマンス最適化）
  if (Math.random() < 0.01) {
    // console.log('📱 DEBUG: touchmove - PC用処理と統一'); // 軽量化
  }
  
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (touch.clientX - rect.left) * scaleX;
  const y = (touch.clientY - rect.top) * scaleY;
  
  // 背景画像の範囲内かチェック（PC用と同じ処理）
  if (!isWithinBackgroundArea(x, y)) {
    console.log('📱 背景画像範囲外 - 描画中断');
    isPaintDrawing = false;
    lastPaintPos = null;
    return;
  }
  
  // ベジェ曲線による滑らかな描画
  pointHistory.push({ x, y });
  if (pointHistory.length > MAX_POINT_HISTORY) {
    pointHistory.shift();
  }
  
  // 点が2つ以上ある場合に描画
  if (pointHistory.length >= 2) {
    const len = pointHistory.length;
    
    if (len === 2) {
      // 2点の場合は直線
      ctx.beginPath();
      ctx.moveTo(pointHistory[0].x, pointHistory[0].y);
      ctx.lineTo(pointHistory[1].x, pointHistory[1].y);
      ctx.stroke();
    } else {
      // 3点の場合はベジェ曲線
      const p0 = pointHistory[len - 3];
      const p1 = pointHistory[len - 2];
      const p2 = pointHistory[len - 1];
      
      // 中点を計算して滑らかな曲線を描画
      const midPoint1 = {
        x: (p0.x + p1.x) / 2,
        y: (p0.y + p1.y) / 2
      };
      const midPoint2 = {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2
      };
      
      ctx.beginPath();
      ctx.moveTo(midPoint1.x, midPoint1.y);
      ctx.quadraticCurveTo(p1.x, p1.y, midPoint2.x, midPoint2.y);
      ctx.stroke();
    }
  }
  
  // 自分の描画コマンドとして保存（PC版と同じ）
  const actualColor = currentPenColor === 'white-red-border' ? '#ffffff' : 
                     (currentPenColor === 'black' ? '#000' : 
                     (currentPenColor === 'white' ? '#fff' : 
                     (currentPenColor === 'green' ? '#008000' : 
                     (currentPenColor === 'pink' ? '#ff69b4' : currentPenColor))));
  const drawCmd = {
    type: "draw",
    x: x,
    y: y,
    thickness: currentPenThickness,
    color: actualColor
  };
  drawingCommands.push(drawCmd);
  // console.log(`📋 DEBUG: draw保存 - 配列数=${drawingCommands.length}件`); // 軽量化
  
  // WebSocket送信（PC版と同じ）
  const drawMsg = {
    type: "draw",
    x: x,
    y: y,
    thickness: currentPenThickness,
    color: currentPenColor,
    writerId: myWriterId,
    timestamp: Date.now(),
    starEffect: starEffectEnabled,
    fairyDustEffect: fairyDustEffectEnabled,
    canvasSize: {
      width: canvas.width,
      height: canvas.height
    }
  };
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify(drawMsg));
    // 🚀 非侵入的パフォーマンス最適化: ログをさらに減らす
    if (Math.random() < 0.01) {
      /* console.log("📤 タブレット描画継続データ送信:", {
        writerId: drawMsg.writerId,
        x: Math.round(x),
        y: Math.round(y)
      }); */ // 軽量化
    }
  }
  
  lastPaintPos = { x, y };
});

// 🔸 ビデオサイズ設定関数
function setVideoSize(size) {
  currentVideoSize = size;
  
  // ボタンの選択状態を更新
  document.getElementById("size100Btn").classList.remove("selected");
  document.getElementById("size90Btn").classList.remove("selected");
  document.getElementById("size80Btn").classList.remove("selected");
  
  document.getElementById(`size${size}Btn`).classList.add("selected");
  
  // console.log(`📐 ビデオサイズを${size}%に設定`);
  
  // 受信側にサイズ情報を送信
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ 
      type: "videoSize", 
      size: size 
    }));
  }
}

// 🔸 ビデオ再生関数
function playVideo() {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ 
      type: "playVideo",
      size: currentVideoSize
    }));
    // console.log(`📹 ビデオ再生指示を送信（サイズ: ${currentVideoSize}%）`);
  } else {
    console.error("❌ WebSocket接続なし");
  }
}

// 🔸 Dev Tools 関数
function toggleDevTools() {
  const devTools = document.getElementById("devTools");
  devTools.style.display = devTools.style.display === "none" ? "block" : "none";
}

function updateCanvasScale(value) {
  canvasScale = parseFloat(value);
  document.getElementById("canvasScaleValue").textContent = value + "x";
  
  // キャンバスサイズ変更を受信側に通知
  if (socket.readyState === WebSocket.OPEN && myWriterId) {
    const canvasSize = {
      width: canvas.width,
      height: canvas.height
    };
    
    socket.send(JSON.stringify({
      type: "canvasSizeUpdate",
      canvasSize: canvasSize,
      scale: canvasScale,
      writerId: myWriterId
    }));
    
    console.log(`📡 キャンバスサイズ変更を受信側に送信: ${canvas.width}x${canvas.height}, scale=${canvasScale}`);
  }
}

function updateAnimationStartWait(value) {
  animationStartWaitTime = parseFloat(value);
  document.getElementById("animationStartWaitValue").textContent = value + "秒";
}

function updateRotationWait(value) {
  rotationWaitTime = parseFloat(value);
  document.getElementById("rotationWaitValue").textContent = value + "秒";
}

function sendDevSettings() {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      type: "devSettings",
      canvasScale: canvasScale,
      animationStartWaitTime: animationStartWaitTime,
      rotationWaitTime: rotationWaitTime
    }));
    // console.log(`🔧 Dev設定送信: scale=${canvasScale}, animationWait=${animationStartWaitTime}, rotationWait=${rotationWaitTime}`);
    // console.log("✅ 設定を受信側に送信しました");
  } else {
    console.error("❌ WebSocket接続なし");
  }
}

// 描画データを保存する配列
let drawingCommands = [];

function saveRotatedImage() {
  // console.log('📤 送信ボタン: 180度回転画像ダウンロード開始');
  
  try {
    // 最終的な画像用のcanvasを作成
    const finalCanvas = document.createElement('canvas');
    const finalCtx = finalCanvas.getContext('2d');
    finalCanvas.width = canvas.width;
    finalCanvas.height = canvas.height;
    
    // 1. 背景を先に描画（回転させない）
    if (backgroundImage) {
      finalCtx.drawImage(backgroundImage, 0, 0, finalCanvas.width, finalCanvas.height);
    } else {
      // 白背景で塗りつぶし
      finalCtx.fillStyle = '#ffffff';
      finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
    }
    
    // 2. ペイントデータのみを180度回転させて描画
    if (drawingCommands.length > 0) {
      // console.log(`🎨 描画コマンド数: ${drawingCommands.length}`);
      
      // 180度回転変換を適用
      finalCtx.save();
      finalCtx.translate(finalCanvas.width, finalCanvas.height);
      finalCtx.rotate(Math.PI);
      
      // 描画コマンドを実行（座標は元のまま、キャンバスが回転している）
      drawingCommands.forEach(cmd => {
        if (cmd.type === 'start') {
          finalCtx.beginPath();
          finalCtx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'draw') {
          finalCtx.lineWidth = cmd.thickness || 8;
          finalCtx.strokeStyle = cmd.color || 'black';
          finalCtx.lineTo(cmd.x, cmd.y);
          finalCtx.stroke();
        }
      });
      
      finalCtx.restore();
      // console.log('🔄 ペイントデータの180度回転処理完了');
    } else {
      // console.log('⚠️ 描画データがありません');
    }
    
    // 自動ダウンロード
    const imageDataUrl = finalCanvas.toDataURL('image/png');
    const link = document.createElement('a');
    const now = new Date();
    const fileName = `rotated_${now.getFullYear()}${(now.getMonth() + 1)
      .toString().padStart(2, "0")}${now.getDate().toString().padStart(2, "0")}_${now
      .getHours().toString().padStart(2, "0")}${now.getMinutes().toString().padStart(2, "0")}${now
      .getSeconds().toString().padStart(2, "0")}.png`;
    
    link.download = fileName;
    link.href = imageDataUrl;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // console.log('📥 180度回転画像ダウンロード完了:', fileName);
    
  } catch (error) {
    console.error('❌ 180度回転画像保存エラー詳細:', error.message, error);
    alert('画像の保存に失敗しました: ' + error.message);
  }
}

// 現在の状態から更に180度回転させて保存する関数
function saveDoubleRotatedImage() {
  // 音楽制御は送信側では無効化（受信側のみで音楽再生）
  
  console.log(`🔄🔄🔄 送信ボタン押下: globalSend送信開始→${animationStartWaitTime}秒後にアニメーション開始 🔄🔄🔄`);
  
  // 🔸 まず受信側に印刷指示を送信（データが残っている状態で）
  console.log('📤📤📤 受信側にglobalSend指示を送信中... 📤📤📤');
  socket.send(JSON.stringify({
    type: "globalSend",
    writerId: myWriterId,
    timestamp: Date.now(),
    animationStartWaitTime: animationStartWaitTime,
    rotationWaitTime: rotationWaitTime
  }));
  console.log('✅✅✅ 受信側へのglobalSend指示送信完了 ✅✅✅');
  
  // 🔸 少し待ってから送信側の印刷処理のみ実行
  setTimeout(() => {
    // console.log('🖨️ 送信側印刷処理を実行');
    // console.log(`📝 印刷前の描画コマンド数: ${drawingCommands.length}`);
    actualPrintProcess();
    // console.log('✅ 送信側印刷処理完了（描画データは保持）');
  }, 500); // 受信側の印刷処理が開始されるまで500ms待機
  
  // 🔄 送信直後に新しい描画を可能にするため、hasSentDataフラグを即座にリセット
  // 送信済みフラグをリセットして、すぐに新しい描画を可能にする
  hasSentData = false;
  console.log('🔓 送信直後: hasSentDataをリセット - 新しい描画と他writerデータ受信を再開');
  
  // 🔄 受信側のアニメーション完了後に送信者側のデータクリアと自動Clear処理を実行
  const totalAnimationTime = (animationStartWaitTime + 1 + rotationWaitTime + 2) * 1000; // アニメーション開始待機 + 回転1秒 + 回転後待機 + スライド2秒
  console.log(`🔄 送信完了 → ${totalAnimationTime/1000}秒後（アニメーション完了後）に送信者データクリア + 自動Clear処理を実行`);
  setTimeout(() => {
    // 🔸 送信者側のデータクリア（アニメーション完了後）
    otherWritersData = {};
    drawingCommands = []; // 🔥 アニメーション完了後に自分の描画コマンドをクリア
    console.log('🧹 アニメーション完了後: 全描画データをクリア');
    console.log('🧹 otherWritersData遅延クリア:', Object.keys(otherWritersData).length);
    console.log('🧹 drawingCommands遅延クリア:', drawingCommands.length);
    
    // キャンバスを再描画（空の状態）- 遅延実行
    if (window.saveDoubleRotatedRedrawTimeout) {
      clearTimeout(window.saveDoubleRotatedRedrawTimeout);
    }
    
    window.saveDoubleRotatedRedrawTimeout = setTimeout(() => {
      redrawCanvasWithOthers();
      window.saveDoubleRotatedRedrawTimeout = null;
    }, 10);
    
    // 全書き手同期のためのクリア命令を送信
    socket.send(JSON.stringify({ 
      type: "globalClear",
      writerId: myWriterId,
      timestamp: Date.now()
    }));
    console.log('📤 自動Clear: 全書き手にクリア指示を送信');
    console.log('✅ 自動Clear処理完了（アニメーション完了後）');
  }, totalAnimationTime); // アニメーション完了後に自動Clear実行
  
  // 🔸 送信ボタンの視覚的フィードバック
  const sendButton = event.target;
  sendButton.style.transform = 'scale(0.95)';
  sendButton.style.backgroundColor = '#ff1493';
  sendButton.style.color = '#fff';
  sendButton.textContent = '送信中...';
  sendButton.disabled = true;
  
  // 🔸 打ち上げ花火演出を追加（受信側と同期）
  // 回転アニメーション完了後1秒で実行するようにタイミング調整
  const fireworksCheckbox = document.getElementById('fireworksEffect');
  if (fireworksCheckbox.checked) {
    const fireworksDelay = animationStartWaitTime * 1000 + 2500; // アニメーション開始待機時間 + 回転時間(1.5秒) + 1秒
    setTimeout(() => {
      // console.log('🎆 送信側：回転アニメーション完了後1秒で花火を実行');
      createFireworks();
    }, fireworksDelay);
  } else {
    // console.log('🎆 花火演出はオフに設定されています');
  }
  
  // 🔸 紙吹雪演出を追加（受信側と同期）
  const confettiCheckbox = document.getElementById('confettiEffect');
  if (confettiCheckbox.checked) {
    const confettiDelay = animationStartWaitTime * 1000 + 2500 + (rotationWaitTime * 1000) - 1500; // 花火と同じタイミング + 回転後待機時間 - 1.5秒前
    setTimeout(() => {
      // console.log('🎊 送信側：紙吹雪演出を実行');
      createConfetti();
    }, confettiDelay);
  } else {
    // console.log('🎊 紙吹雪演出はオフに設定されています');
  }
  
  // ボタンを元に戻す
  setTimeout(() => {
    sendButton.style.transform = 'scale(1)';
    sendButton.style.backgroundColor = '';
    sendButton.style.color = '';
    sendButton.textContent = '送信';
    sendButton.disabled = false;
  }, 2000);
  
  // 🔸 印刷処理は既に上で実行済み
  
  // 🔸 印刷処理開始の設定時間後に回転アニメーションを開始
  // console.log(`🎬 印刷処理開始から${animationStartWaitTime}秒後に回転アニメーション実行予定`);
  
  // 設定時間後にWebSocket経由で受信側にアニメーション開始を通知
  setTimeout(() => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        type: "startRotationAnimation",
        waitTime: rotationWaitTime, // 回転後待機時間を設定値から取得
        fireworksEnabled: document.getElementById('fireworksEffect').checked,
        confettiEnabled: document.getElementById('confettiEffect').checked
      }));
      // console.log(`🎬 印刷開始から${animationStartWaitTime}秒後に受信側にアニメーション開始を送信 (回転後${rotationWaitTime}秒待機)`);
    }
  }, animationStartWaitTime * 1000); // アニメーション開始待機時間（秒をミリ秒に変換）
  
  // 🔸 送信ボタン押下から10秒後にクリアを実行（印刷が即座に開始されるため）
  setTimeout(() => {
    // console.log('🧹 送信ボタン押下から10秒後にクリア実行');
    
    // 🔒 送信済みフラグは維持（手動でClearボタンを押すまで他のwriterデータを受信しない）
    // hasSentData = false; // この行をコメントアウト
    // console.log('🔒 送信済みフラグを維持 - 他のwriterデータ受信を継続して拒否');
    
    // キャンバスを完全にクリア
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 背景画像があれば再描画（回転なし）
    if (backgroundImage) {
      drawBackgroundImage(ctx, backgroundImage, canvas);
      // console.log('🖼️ 背景画像を再描画');
    }
    
    // 全ての描画データを完全クリア
    drawingCommands = [];
    otherWritersData = {};
    // console.log('🧹 送信側：全描画データを完全クリア');
    // console.log('🧹 drawingCommands配列をクリア:', drawingCommands.length);
    // console.log('🧹 otherWritersData配列をクリア:', Object.keys(otherWritersData).length);
    
    // 受信側にもクリア指示を送信
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "clear" }));
      // console.log('📤 受信側にクリア指示を送信');
    }
    
    // console.log('✅ 送信ボタン押下から10秒後のクリア完了');
  }, 10000); // 送信ボタン押下から10秒後にクリア
}

// 実際の印刷処理を行う関数
function actualPrintProcess() {
  try {
    // 新しいcanvasを作成（taintedにならないように）
    const cleanCanvas = document.createElement('canvas');
    const cleanCtx = cleanCanvas.getContext('2d');
    cleanCanvas.width = canvas.width;
    cleanCanvas.height = canvas.height;
    
    // 白背景で塗りつぶし（背景画像は使わない）
    cleanCtx.fillStyle = '#ffffff';
    cleanCtx.fillRect(0, 0, cleanCanvas.width, cleanCanvas.height);
    
    // 保存された描画コマンドを再実行（360度回転 = 元の向き）
    if (drawingCommands.length > 0) {
      // console.log(`🎨 描画コマンド数: ${drawingCommands.length}`);
      
      // 描画コマンドを実行（回転なし = 元の向き）
      drawingCommands.forEach(cmd => {
        if (cmd.type === 'start') {
          cleanCtx.beginPath();
          cleanCtx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'draw') {
          cleanCtx.lineWidth = cmd.thickness || 8;
          cleanCtx.strokeStyle = cmd.color || 'black';
          cleanCtx.lineTo(cmd.x, cmd.y);
          cleanCtx.stroke();
        }
      });
      
      // console.log('🔄 ペイントデータの360度回転処理完了（元の向き）');
    } else {
      // 描画データがない場合は何もしない
      // console.log('🔄 描画データがないため、白紙で印刷');
      // console.log('🔄 canvasには何も描画しません');
      // console.log('🔄 drawingCommands配列:', drawingCommands);
    }
    
    // 自動印刷処理
    const imageDataUrl = cleanCanvas.toDataURL('image/png');
    
    // WebSocket経由で受信側に印刷指示を送信
    if (socket && socket.readyState === WebSocket.OPEN) {
      // console.log('🖨️ WebSocket経由で受信側に印刷データを送信');
      socket.send(JSON.stringify({
        type: "printRotatedImage",
        imageData: imageDataUrl,
        printType: 'double_rotated',
        paperSize: currentPaperSize,
        printMode: currentPrintMode,
        switchBotEnabled: document.getElementById('switchBotEffect').checked
      }));
      // console.log('✅ 更に180度回転画像の印刷処理を開始');
    } else {
      // フォールバック: ダウンロード
      // console.log('⚠️ WebSocket接続がないため、ダウンロードします');
      const link = document.createElement('a');
      const now = new Date();
      const fileName = `double_rotated_${now.getFullYear()}${(now.getMonth() + 1)
        .toString().padStart(2, "0")}${now.getDate().toString().padStart(2, "0")}_${now
        .getHours().toString().padStart(2, "0")}${now.getMinutes().toString().padStart(2, "0")}${now
        .getSeconds().toString().padStart(2, "0")}.png`;
      
      link.download = fileName;
      link.href = imageDataUrl;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // console.log('📥 更に180度回転画像ダウンロード完了:', fileName);
    }
    
    
  } catch (error) {
    console.error('❌ 更に180度回転画像保存エラー詳細:', error.message, error);
    alert('更に180度回転画像の保存に失敗しました: ' + error.message);
  }
}

// 🤖 SwitchBotテスト関数（送信側からメッセージを送信）
function testSwitchBot() {
  // console.log("🤖 送信側からSwitchBotテスト実行");
  
  // 受信側にSwitchBotテストメッセージを送信
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      type: "switchBotTest"
    }));
    // console.log("🤖 受信側にSwitchBotテストメッセージを送信");
  } else {
    console.error("❌ WebSocket接続が閉じています");
    alert("WebSocket接続が閉じています");
  }
}

// 🎨 テーマ切り替え関数
function toggleTheme() {
  const body = document.body;
  const themeToggle = document.getElementById('themeToggle');
  
  if (body.classList.contains('modern')) {
    // モダン → クラシック
    body.classList.remove('modern');
    body.classList.add('classic');
    themeToggle.textContent = '🎨 モダン';
    // console.log('📝 クラシックテーマに切り替え');
  } else {
    // クラシック → モダン
    body.classList.remove('classic');
    body.classList.add('modern');
    themeToggle.textContent = '📝 クラシック';
    // console.log('🎨 モダンテーマに切り替え');
  }
}

// 背景画像の変形パラメータ
let backgroundScale = 1.0; // スケール（大きさ）
let backgroundOffsetY = 0; // 垂直オフセット

// 🎬 送信側動画関数群
function createSenderVideo() {
  // console.log('🎬 送信側に動画を作成');
  
  // 既存の動画要素を削除
  if (senderVideoElement) {
    senderVideoElement.remove();
  }
  
  // 新しい動画要素を作成（キャンバス位置に配置）
  senderVideoElement = document.createElement('video');
  senderVideoElement.src = './back6.mp4';
  
  // 🔍 デバッグ情報: 現状把握
  const canvasRect = canvas.getBoundingClientRect();
  // console.log('📊 書き手側デバッグ情報:');
  // console.log(`  canvasScale値: ${canvasScale}`);
  // console.log(`  キャンバス位置: (${canvasRect.left}, ${canvasRect.top})`);
  // console.log(`  キャンバスサイズ: ${canvasRect.width} x ${canvasRect.height}`);
  // console.log(`  ウィンドウサイズ: ${window.innerWidth} x ${window.innerHeight}`);
  
  // ステップ1: キャンバスの情報を確認
  // console.log('📏 ステップ1: キャンバス情報確認');
  // console.log(`  キャンバスサイズ: ${canvas.width} x ${canvas.height}`);
  // console.log(`  キャンバス画面位置: (${canvasRect.left}, ${canvasRect.top})`);
  
  // ステップ2: キャンバスの中心座標を計算
  const canvasCenterX = canvas.width / 2;
  const canvasCenterY = canvas.height / 2;
  // console.log('🎯 ステップ2: キャンバス中心座標計算');
  // console.log(`  キャンバス中心（相対座標）: (${canvasCenterX}, ${canvasCenterY})`);
  
  // ステップ3: 動画のアスペクト比（16:9）を保持しながらキャンバスに収まるサイズを計算
  const videoAspectRatio = 16 / 9;
  const canvasAspectRatio = canvas.width / canvas.height;
  let videoWidth, videoHeight;
  
  if (canvasAspectRatio > videoAspectRatio) {
    // キャンバスの方が横長 → 高さを基準にする
    videoHeight = canvas.height;
    videoWidth = videoHeight * videoAspectRatio;
  } else {
    // キャンバスの方が縦長 → 幅を基準にする
    videoWidth = canvas.width;
    videoHeight = videoWidth / videoAspectRatio;
  }
  
  // console.log('📐 ステップ3: 動画サイズ計算（16:9比率を保持）');
  // console.log(`  計算された動画サイズ: ${videoWidth.toFixed(1)} x ${videoHeight.toFixed(1)}`);
  // console.log(`  キャンバスに対する比率: ${(videoWidth/canvas.width*100).toFixed(1)}% x ${(videoHeight/canvas.height*100).toFixed(1)}%`);
  
  // ステップ4: 動画の画面絶対座標を計算（キャンバス中心に配置）
  const canvasScreenCenterX = canvasRect.left + canvasCenterX;
  const canvasScreenCenterY = canvasRect.top + canvasCenterY;
  const videoScreenLeft = canvasScreenCenterX - (videoWidth / 2);
  const videoScreenTop = canvasScreenCenterY - (videoHeight / 2);
  
  // console.log('📍 ステップ4: 動画配置座標計算（画面絶対座標）');
  // console.log(`  キャンバス中心（画面座標）: (${canvasScreenCenterX.toFixed(1)}, ${canvasScreenCenterY.toFixed(1)})`);
  // console.log(`  動画左上座標（画面座標）: (${videoScreenLeft.toFixed(1)}, ${videoScreenTop.toFixed(1)})`);
  
  // ステップ5: 動画を画面絶対座標で配置（レイアウト影響を完全排除）
  senderVideoElement.style.cssText = `
    position: fixed !important;
    top: ${videoScreenTop}px !important;
    left: ${videoScreenLeft}px !important;
    width: ${videoWidth}px !important;
    height: ${videoHeight}px !important;
    z-index: 50 !important;
    object-fit: contain !important;
    pointer-events: none !important;
    margin: 0 !important;
    padding: 0 !important;
    border: 0 !important;
    transform: none !important;
    transform-origin: initial !important;
  `;
  
  // ステップ6: 理論上のずれ確認計算（画面座標）
  const theoreticalVideoCenterX = videoScreenLeft + (videoWidth / 2);
  const theoreticalVideoCenterY = videoScreenTop + (videoHeight / 2);
  const theoreticalOffsetX = theoreticalVideoCenterX - canvasScreenCenterX;
  const theoreticalOffsetY = theoreticalVideoCenterY - canvasScreenCenterY;
  
  // console.log('✅ ステップ6: 理論上のずれ確認計算（画面座標）');
  // console.log(`  計算上の動画中心: (${theoreticalVideoCenterX.toFixed(1)}, ${theoreticalVideoCenterY.toFixed(1)})`);
  // console.log(`  キャンバス中心: (${canvasScreenCenterX.toFixed(1)}, ${canvasScreenCenterY.toFixed(1)})`);
  // console.log(`  理論上のずれ: X=${theoreticalOffsetX.toFixed(1)}px, Y=${theoreticalOffsetY.toFixed(1)}px`);
  
  if (Math.abs(theoreticalOffsetX) < 0.1 && Math.abs(theoreticalOffsetY) < 0.1) {
    // console.log('✅ 理論上は完璧！');
  } else {
    // console.log('⚠️ 計算にエラーがあります');
  }
  
  // 最初のフレームで停止
  senderVideoElement.muted = true;
  
  // メタデータ読み込み後に最初のフレームに移動
  senderVideoElement.addEventListener('loadedmetadata', () => {
    senderVideoElement.currentTime = 0;
    // console.log('🎬 送信側動画メタデータ読み込み完了');
    
    // 実際の配置後の座標を確認
    setTimeout(() => {
      const videoRect = senderVideoElement.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      
      // 詳細なデバッグ情報
      // console.log('🔍 詳細デバッグ:');
      // console.log(`  動画要素の実際のstyle.top: ${senderVideoElement.style.top}`);
      // console.log(`  動画要素の実際のstyle.left: ${senderVideoElement.style.left}`);
      // console.log(`  動画要素のgetBoundingClientRect: left=${videoRect.left}, top=${videoRect.top}, width=${videoRect.width}, height=${videoRect.height}`);
      
      // 画面上の中央座標を計算
      const videoCenterScreenX = videoRect.left + (videoRect.width / 2);
      const videoCenterScreenY = videoRect.top + (videoRect.height / 2);
      const canvasCenterScreenX = canvasRect.left + (canvasRect.width / 2);
      const canvasCenterScreenY = canvasRect.top + (canvasRect.height / 2);
      
      // ずれを計算
      const screenOffsetX = videoCenterScreenX - canvasCenterScreenX;
      const screenOffsetY = videoCenterScreenY - canvasCenterScreenY;
      
      // console.log('🎯 実際の画面座標での中央点確認:');
      // console.log(`  動画中央点（画面座標）: (${videoCenterScreenX.toFixed(1)}, ${videoCenterScreenY.toFixed(1)})`);
      // console.log(`  キャンバス中央点（画面座標）: (${canvasCenterScreenX.toFixed(1)}, ${canvasCenterScreenY.toFixed(1)})`);
      // console.log(`  実際のずれ: X=${screenOffsetX.toFixed(1)}px, Y=${screenOffsetY.toFixed(1)}px`);
      
      if (Math.abs(screenOffsetX) < 1 && Math.abs(screenOffsetY) < 1) {
        // console.log('✅ 完璧！ずれが解消されました');
      } else {
        // console.log('⚠️ まだずれています - さらなる調整が必要');
      }
    }, 100);
  });
  
  // bodyに直接追加してレイアウトの影響を回避
  document.body.appendChild(senderVideoElement);
  isSenderVideoActive = true;
  
  // console.log('🎬 送信側動画作成完了 - キャンバス位置に配置');
}

function playSenderVideo() {
  if (senderVideoElement) {
    // console.log('🎬 送信側扉開く演出開始');
    
    // 音声再生は送信側では削除（受信側のみで音楽再生）
    
    // 4秒後に動画再生開始
    setTimeout(() => {
      // 動画終了時の処理を追加
      senderVideoElement.addEventListener('ended', () => {
        // console.log('🎬 送信側動画終了 - 背景4ボタンと同じ処理を実行');
        
        // 動画を非表示
        senderVideoElement.style.display = 'none';
        senderVideoElement.style.visibility = 'hidden';
        
        // 背景4ボタンを押したと同じ処理を実行
        setBackground('./back6.png');
        
        // console.log('🎬 送信側動画非表示完了、背景4設定完了');
      });
      
      senderVideoElement.play().catch(e => {
        console.error('❌ 送信側動画再生エラー:', e);
      });
      // console.log('🎬 送信側動画再生開始（4秒後）');
    }, 4000);
  }
}

function stopSenderVideoAtLastFrame() {
  if (senderVideoElement && senderVideoElement.tagName === 'VIDEO') {
    try {
      // console.log('🎬 送信側動画を最後のシーンで停止');
      
      // 最終フレームに移動して停止
      if (senderVideoElement.duration) {
        senderVideoElement.currentTime = senderVideoElement.duration - 0.1;
      }
      senderVideoElement.pause();
      
      // 特殊背景状態をリセット
      specialBackgroundState = 'ready';
      
      // キャンバス状態を確実にリセット
      ctx.globalCompositeOperation = 'source-over';
      
      // console.log('🎬 送信側動画最終フレームで停止完了');
      
    } catch (error) {
      console.error('❌ 送信側動画停止エラー:', error);
    }
  }
}

function hideSenderVideo() {
  if (senderVideoElement) {
    try {
      // console.log('🎬 送信側動画を非表示にする');
      
      const mainContainer = document.querySelector('.main-container');
      
      // 動画要素を確実に削除（停止してから削除）
      if (senderVideoElement && senderVideoElement.tagName === 'VIDEO') {
        senderVideoElement.pause();
        senderVideoElement.src = '';
        senderVideoElement.remove();
        // console.log('🎬 送信側動画要素を削除');
      }
      
      // 変数をクリア
      senderVideoElement = null;
      isSenderVideoActive = false;
      
      // 背景画像もクリア（動画キャプチャを背景にしない）
      backgroundImage = null;
      
      // キャンバス背景を通常状態に戻す
      canvas.style.backgroundColor = 'transparent';
      
      // キャンバスをクリア
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 特殊背景状態をリセット
      specialBackgroundState = 'ready';
      
      // キャンバス状態を確実にリセット
      ctx.globalCompositeOperation = 'source-over';
      
      // console.log('🎬 送信側動画非表示完了 - 通常モードに戻る');
      
    } catch (error) {
      console.error('❌ 送信側動画非表示エラー:', error);
    }
  }
}

function stopSenderVideo() {
  if (senderVideoElement) {
    // console.log('🎬 送信側動画終了');
    senderVideoElement.pause();
    // 最終フレームに移動
    if (senderVideoElement.duration) {
      senderVideoElement.currentTime = senderVideoElement.duration - 0.1;
    }
  }
}

// 送信側PNG背景表示関数
function showSenderPngBackground() {
  // console.log('🖼️ 送信側PNG背景表示開始');
  
  // 動画を非表示にする
  if (senderVideoElement) {
    senderVideoElement.style.display = 'none';
    // console.log('🎬 送信側動画を非表示');
  }
  
  // PNG画像要素を作成
  const pngElement = document.createElement('img');
  pngElement.id = 'senderPngBackground';
  pngElement.src = './back6.png';
  
  // 動画と同じ位置・サイズでPNG画像を配置
  if (senderVideoElement) {
    const videoStyle = senderVideoElement.style;
    pngElement.style.cssText = `
      position: fixed !important;
      top: ${videoStyle.top} !important;
      left: ${videoStyle.left} !important;
      width: ${videoStyle.width} !important;
      height: ${videoStyle.height} !important;
      z-index: 50 !important;
      object-fit: contain !important;
      pointer-events: none !important;
      margin: 0 !important;
      padding: 0 !important;
      border: 0 !important;
      transform: none !important;
      transform-origin: initial !important;
    `;
  }
  
  // 画像読み込み完了後に表示
  pngElement.onload = () => {
    document.body.appendChild(pngElement);
    // console.log('🖼️ 送信側PNG背景表示完了');
  };
  
  pngElement.onerror = () => {
    console.error('❌ PNG画像の読み込みに失敗しました');
  };
}

// 傾きセンサー機能は削除されました

// キーボードイベントリスナーを追加（矢印キーで操作 - デスクトップ用）
document.addEventListener('keydown', function(event) {
  // 入力フィールドにフォーカスがある場合は無視
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
    return;
  }
  
  switch(event.key) {
    case 'ArrowUp':
      event.preventDefault();
      // 背景を上に移動・拡大
      backgroundOffsetY = Math.max(backgroundOffsetY - 20, -100);
      backgroundScale = Math.min(backgroundScale + 0.1, 2.0);
      updateBackgroundTransform();
      // console.log(`⬆️ 矢印キー上 - オフセット: ${backgroundOffsetY}, スケール: ${backgroundScale.toFixed(1)}`);
      break;
    case 'ArrowDown':
      event.preventDefault();
      // 背景を下に移動・縮小
      backgroundOffsetY = Math.min(backgroundOffsetY + 20, 100);
      backgroundScale = Math.max(backgroundScale - 0.1, 0.5);
      updateBackgroundTransform();
      // console.log(`⬇️ 矢印キー下 - オフセット: ${backgroundOffsetY}, スケール: ${backgroundScale.toFixed(1)}`);
      break;
    case 'ArrowLeft':
      event.preventDefault();
      setBackground('./back3.png');
      // console.log('⬅️ 矢印キー左 - 背景1に変更');
      break;
    case 'ArrowRight':
      event.preventDefault();
      setBackground('./back4.png');
      // console.log('➡️ 矢印キー右 - 背景3に変更');
      break;
  }
});

// 背景画像の変形を適用する関数
function updateBackgroundTransform() {
  if (backgroundImage) {
    // キャンバスを再描画
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 変形パラメータを適用して背景を描画（アスペクト比保持）
    const imageAspect = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
    const canvasAspect = canvas.width / canvas.height;
    
    let scaledWidth, scaledHeight;
    
    if (imageAspect > canvasAspect) {
      // 画像が横長の場合、幅をキャンバス幅に合わせる
      scaledWidth = canvas.width * backgroundScale;
      scaledHeight = scaledWidth / imageAspect;
    } else {
      // 画像が縦長の場合、高さをキャンバス高さに合わせる
      scaledHeight = canvas.height * backgroundScale;
      scaledWidth = scaledHeight * imageAspect;
    }
    
    const offsetX = (canvas.width - scaledWidth) / 2;
    const offsetY = (canvas.height - scaledHeight) / 2 + backgroundOffsetY;
    
    drawBackgroundImage(ctx, backgroundImage, canvas);
    
    // 描画コマンドを再実行
    if (drawingCommands && drawingCommands.length > 0) {
      drawingCommands.forEach(cmd => {
        if (cmd.type === 'start') {
          ctx.beginPath();
          ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'draw') {
          ctx.lineWidth = cmd.thickness || currentPenThickness;
          ctx.strokeStyle = cmd.color || currentPenColor;
          ctx.lineTo(cmd.x, cmd.y);
          ctx.stroke();
        }
      });
    }
    
    // 受信側にも変形パラメータを送信
    if (socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        type: "backgroundTransform",
        scale: backgroundScale,
        offsetY: backgroundOffsetY
      }));
    }
  }
}

// 初期化処理：起動時に背景2を設定
window.addEventListener('DOMContentLoaded', () => {
  // console.log('🚀 初期化処理開始');
  
  // デバイス検出と設定適用
  const deviceInfo = DeviceManager.applyDeviceSettings();
  
  // ダブルタップズーム防止用の変数
  let lastTouchEnd = 0;
  
  // タブレットでのピンチズーム防止（ペン描画時も含む）
  document.addEventListener('touchstart', function(e) {
    // キャンバス上のタッチは全て描画として扱い、ズーム無効
    if (e.target.tagName === 'CANVAS' || e.target.id === 'drawCanvas') {
      e.preventDefault();
      return false;
    }
    if (e.touches.length > 1) {
      e.preventDefault();
    }
  }, { passive: false });
  
  document.addEventListener('touchend', function(e) {
    const now = new Date().getTime();
    if (now - lastTouchEnd <= 300) {
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, { passive: false });
  
  document.addEventListener('touchmove', function(e) {
    // キャンバス上での全てのタッチムーブをズーム無効に
    if (e.target.tagName === 'CANVAS' || e.target.id === 'drawCanvas') {
      e.preventDefault();
      return false;
    }
    if (e.touches.length > 1) {
      e.preventDefault();
    }
  }, { passive: false });
  
  // Pointer Events APIでペン入力も制御
  document.addEventListener('pointerdown', function(e) {
    if (e.target.tagName === 'CANVAS' || e.target.id === 'drawCanvas') {
      e.preventDefault();
    }
  }, { passive: false });
  
  // Gestureイベント（Safari）も無効化
  document.addEventListener('gesturestart', function(e) {
    e.preventDefault();
  }, false);
  
  document.addEventListener('gesturechange', function(e) {
    e.preventDefault();
  }, false);
  
  document.addEventListener('gestureend', function(e) {
    e.preventDefault();
  }, false);
  
  // キャンバススケール0.7を適用
  updateCanvasScale(0.7);
  
  // Writer IDステータス表示を作成
  createWriterStatusDiv();
  
  // 背景2を自動設定
  setTimeout(() => {
    // console.log('🖼️ 起動時に背景2を自動設定');
    setBackground('./back2.png');
    
    // 背景2ボタンを選択状態にする
    const back2Btn = document.getElementById('back2Btn');
    if (back2Btn) {
      document.querySelectorAll('.bg-btn').forEach(btn => btn.classList.remove('selected'));
      back2Btn.classList.add('selected');
    }
  }, 500); // WebSocket接続を待つため少し遅延
});

// 🎯 座標テスト用関数：右下に短い線を描画
function testDrawRightBottom() {
  console.log('🎯 テスト右下ボタンが押されました');
  
  if (!canvas || !ctx) {
    console.error('❌ キャンバスまたはコンテキストが存在しません');
    alert('キャンバスが初期化されていません');
    return;
  }
  
  // キャンバスサイズを取得
  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;
  
  console.log(`🎯 キャンバスサイズ: ${canvasWidth} x ${canvasHeight}`);
  
  // 右下の位置を計算（キャンバスの右下角から少し内側）
  const margin = 20; // 端からの余白
  const lineLength = 30; // 線の長さ
  
  const startX = canvasWidth - margin - lineLength;
  const startY = canvasHeight - margin - lineLength;
  const endX = canvasWidth - margin;
  const endY = canvasHeight - margin;
  
  console.log(`🎯 テスト線の座標: (${startX}, ${startY}) → (${endX}, ${endY})`);
  
  // 線を描画
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.strokeStyle = '#FF1493'; // 目立つピンク色
  ctx.lineWidth = 4;
  ctx.stroke();
  
  // WebSocketでデータを送信（実際の描画と同じ形式）
  if (socket.readyState === WebSocket.OPEN && myWriterId) {
    // 開始点を送信
    socket.send(JSON.stringify({
      type: "draw",
      x: startX,
      y: startY,
      drawing: true,
      writerId: myWriterId,
      thickness: 4,
      color: '#FF1493',
      starEffect: starEffectEnabled,
      fairyDustEffect: fairyDustEffectEnabled,
      canvasSize: {
        width: canvas.width,
        height: canvas.height
      }
    }));
    
    // 終了点を送信
    setTimeout(() => {
      socket.send(JSON.stringify({
        type: "draw",
        x: endX,
        y: endY,
        drawing: true,
        writerId: myWriterId,
        thickness: 4,
        color: '#FF1493',
        starEffect: starEffectEnabled,
        fairyDustEffect: fairyDustEffectEnabled,
        canvasSize: {
          width: canvas.width,
          height: canvas.height
        }
      }));
      
      // 描画終了を送信
      setTimeout(() => {
        socket.send(JSON.stringify({
          type: "draw",
          x: endX,
          y: endY,
          drawing: false,
          writerId: myWriterId,
          thickness: 4,
          color: '#FF1493',
          starEffect: starEffectEnabled,
          fairyDustEffect: fairyDustEffectEnabled,
          canvasSize: {
            width: canvas.width,
            height: canvas.height
          }
        }));
      }, 50);
    }, 100);
    
    console.log('🎯 右下テスト線のデータを受信側に送信しました');
    alert(`書き手側の右下に線を描画しました\n座標: (${startX}, ${startY}) → (${endX}, ${endY})\n受信側でどの位置に表示されるか確認してください`);
  } else {
    console.error('❌ WebSocket未接続またはWriterID未設定');
    alert('WebSocket接続またはWriterIDに問題があります');
  }
}


</script>
</div>

<div class="color-panel">
  <h3>ペンの色</h3>
  <button class="color-btn selected" style="background: black;" onclick="setPenColor('black')"></button>
  <button class="color-btn" style="background: red;" onclick="setPenColor('red')"></button>
  <button class="color-btn" style="background: blue;" onclick="setPenColor('blue')"></button>
  <button class="color-btn" style="background: green;" onclick="setPenColor('green')"></button>
  <button class="color-btn" style="background: white; border: 4px solid red; box-sizing: border-box;" onclick="setPenColor('white-red-border')"></button>
</div>

<div class="thickness-panel">
  <h3>ペンの太さ</h3>
  <button class="thickness-btn" onclick="setPenThickness(10)" title="太い (+30%)">
    <div style="width: 21px; height: 21px; border-radius: 50%; background: #333; flex-shrink: 0;"></div>
  </button>
  <button class="thickness-btn selected" onclick="setPenThickness(8)" title="標準">
    <div style="width: 16px; height: 16px; border-radius: 50%; background: #333; flex-shrink: 0;"></div>
  </button>
  <button class="thickness-btn" onclick="setPenThickness(6)" title="細い (-25%)">
    <div style="width: 12px; height: 12px; border-radius: 50%; background: #333; flex-shrink: 0;"></div>
  </button>
  <button class="thickness-btn" onclick="setPenThickness(4)" title="とても細い (-50%)">
    <div style="width: 8px; height: 8px; border-radius: 50%; background: #333; flex-shrink: 0;"></div>
  </button>
</div>

<!-- タブレット用の重複コントロールを削除 - シンプルUI -->

</div>

<!-- 視覚エフェクト機能を外部ファイルから読み込み -->
<script src="effects.js"></script>

<!-- 特殊エフェクト機能（ハート・花火・紙吹雪）を外部ファイルから読み込み -->
<script src="special-effects.js"></script>

</body>
</html>
