<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' wss://realtime-sign-server-1.onrender.com ws://localhost:* wss://localhost:*; img-src 'self' data: blob:; media-src 'self';">
  <title>送信側v3.8-integrated</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="modern">
<button id="themeToggle" onclick="toggleTheme()">📝 クラシック</button>

<div class="main-container" style="display: flex; justify-content: center; align-items: flex-start; gap: 20px;">
<div class="canvas-container">
<div style="position: relative; display: inline-block; margin: 50px auto 20px auto;">
  <img src="back2.png" alt="背景画像" style="transform: scale(1.3); display: block;">
  <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: pink; transform: scale(1.3); transform-origin: center;"></div>
  <canvas id="drawCanvas" width="283" height="420" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scale(1.3); transform-origin: center; cursor: crosshair; background: transparent;"></canvas>
</div>

<!-- メインコントロール: Clear、自分だけ削除、送信 -->
<div class="main-controls">
  <button onclick="clearCanvas()">Clear</button>
  <button onclick="clearMyDrawing()" style="background-color: #FF6B6B; color: white;">自分だけ消去</button>
  <button onclick="saveDoubleRotatedImage()" style="background-color: #4CAF50; color: white; font-size: 18px; padding: 12px 24px; font-weight: bold;">渡す</button>
</div>

</div>

<!-- 右サイドバー: ペンの色と太さを並べて配置 -->
<div class="right-sidebar" style="display: flex; gap: 15px; margin-top: 20px;">
  <!-- 左列: 色 -->
  <div class="pen-colors-vertical" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
    <h4 style="margin: 0; font-size: 16px; color: #333;">色</h4>
    <button class="color-btn selected" style="background: black; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('black')"></button>
    <button class="color-btn" style="background: red; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('red')"></button>
    <button class="color-btn" style="background: blue; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('blue')"></button>
    <button class="color-btn" style="background: green; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('green')"></button>
    <button class="color-btn" style="background: white; border: 4px solid red; box-sizing: border-box; width: 50px; height: 50px; border-radius: 50%;" onclick="setPenColor('white-red-border')"></button>
  </div>
  
  <!-- 右列: 太さ -->
  <div class="pen-thickness-vertical" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
    <h4 style="margin: 0; font-size: 16px; color: #333;">太さ</h4>
    <button class="thickness-btn" onclick="setPenThickness(10)" title="太い (+30%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 21px; height: 21px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn" onclick="setPenThickness(8)" title="標準" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 16px; height: 16px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn selected" onclick="setPenThickness(6)" title="細い (-25%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #333; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 12px; height: 12px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn" onclick="setPenThickness(4)" title="とても細い (-50%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 8px; height: 8px; border-radius: 50%; background: #333;"></div>
    </button>
  </div>
</div>
</div>

<!-- 背景選択はDevToolに移動 -->
<div class="button-group">
  <button onclick="toggleDevTools()" style="background-color: #FFA500; color: white;">🔧 Dev Tool</button>
</div>

<div id="devTools" style="display: none; border: 2px solid orange; padding: 10px; margin-top: 10px;">
  <h3>開発者ツール</h3>
  
  <div class="button-group">
    <label>キャンバスサイズ調整:</label>
    <input type="range" id="canvasScale" min="0.1" max="3.0" step="0.05" value="0.7" oninput="updateCanvasScale(this.value)">
    <span id="canvasScaleValue">0.7x</span>
  </div>
  
  <div class="button-group">
    <label>アニメーション開始待機時間（秒）:</label>
    <input type="range" id="animationStartWait" min="0.1" max="10" step="0.1" value="3.3" oninput="updateAnimationStartWait(this.value)">
    <span id="animationStartWaitValue">3.3秒</span>
  </div>
  
  <div class="button-group">
    <label>回転後待機時間（秒）:</label>
    <input type="range" id="rotationWait" min="1" max="10" step="0.5" value="7.5" oninput="updateRotationWait(this.value)">
    <span id="rotationWaitValue">7.5秒</span>
  </div>
  
  <div class="button-group">
    <button onclick="sendDevSettings()">設定を受信側に送信</button>
  </div>
  
  <div class="button-group">
    <label>背景選択:</label>
    <button onclick="setBackground('./back3.png')">背景1</button>
    <button onclick="setBackground('./back2.png')">背景2</button>
    <button onclick="setBackground('./back4.png')">背景3</button>
    <button onclick="setBackground('./back6.png')">背景4</button>
    <button onclick="setBackground(null)">白</button>
    <button onclick="setSpecialBackgroundToggle()" style="background: linear-gradient(45deg, #ff1493, #00ffff); color: white;">🎬 動画背景</button>
  </div>
  
  <hr style="margin: 15px 0;">
  
  <div class="button-group">
    <label>テスト演出:</label>
    <button onclick="createFireworks()" style="background: linear-gradient(45deg, #ff4500, #ffd700); color: white;">🎆 花火テスト</button>
    <button onclick="createConfetti()" style="background: linear-gradient(45deg, #ff69b4, #00fa9a); color: white;">🎊 紙吹雪テスト</button>
  </div>
  
  <div class="button-group">
    <label>ビデオサイズ:</label>
    <button id="size100Btn" class="selected" onclick="setVideoSize(100)">100%</button>
    <button id="size90Btn" onclick="setVideoSize(90)">90%</button>
    <button id="size80Btn" onclick="setVideoSize(80)">80%</button>
  </div>
  
  <div class="button-group">
    <button onclick="playVideo()" style="background-color: #FF6B6B; color: white;">📹 ビデオ再生</button>
  </div>
  
  <div class="button-group">
    <label>エフェクト:</label>
    <input type="checkbox" id="starEffect" checked onchange="toggleStarEffect()">
    <label for="starEffect">星</label>
    <input type="checkbox" id="fairyDustEffect" onchange="toggleFairyDustEffect()" checked>
    <label for="fairyDustEffect">妖精の粉</label>
    <input type="checkbox" id="heartEffect" onchange="toggleHeartEffect()">
    <label for="heartEffect">💖 ハート</label>
    <input type="checkbox" id="penSoundEffect" onchange="togglePenSound()">
    <label for="penSoundEffect">🎵 ペン音</label>
  </div>
  
  <div class="button-group">
    <label>送信後演出:</label>
    <input type="checkbox" id="fireworksEffect" checked>
    <label for="fireworksEffect">🎆 花火</label>
    <input type="checkbox" id="confettiEffect" checked>
    <label for="confettiEffect">🎊 紙吹雪</label>
    <input type="checkbox" id="backgroundDebug" onchange="toggleBackgroundDebug()">
    <label for="backgroundDebug">🔍 背景デバッグ</label>
  </div>
  
  <div class="button-group">
    <label>用紙サイズ:</label>
    <button id="a4Btn" class="selected" onclick="setPaperSize('A4')">A4</button>
    <button id="lBtn" onclick="setPaperSize('L')">L判</button>
    <button id="posterBtn" onclick="setPaperSize('poster')">ポストカード</button>
  </div>
  
  <div class="button-group">
    <label>印刷モード:</label>
    <button id="drawOnlyBtn" class="selected" onclick="setPrintMode('drawOnly')">描画モード</button>
    <button id="fullModeBtn" onclick="setPrintMode('fullMode')">フルモード</button>
  </div>
  
  <hr style="margin: 15px 0;">
  
  <div class="button-group">
    <label>SwitchBot:</label>
    <input type="checkbox" id="switchBotEffect">
    <label for="switchBotEffect">🤖 バブル</label>
  </div>
  
  <div class="button-group">
    <button onclick="testSwitchBot()" style="background-color: #FF6B35; color: white;">🤖 Botテスト</button>
  </div>
  
  <div class="button-group">
    <label>座標テスト:</label>
    <button onclick="testDrawRightBottom()" style="background-color: #FF1493; color: white;">テスト右下</button>
  </div>
</div>

<div id="countdown"></div>

<script>
const canvas = document.getElementById("drawCanvas");

const ctx = canvas.getContext("2d");
let drawing = false;
let socket = new WebSocket("wss://realtime-sign-server-1.onrender.com");
let myWriterId = null; // 自分のwriter ID
let otherWritersData = {}; // 他の執筆者のデータ

// 描画状態管理用グローバル変数
let isPaintDrawing = false;
let lastPaintPos = null;

// 背景画像の範囲を計算する関数（グローバル）
let mySessionId = null; // セッション固有ID
let backgroundImage = null;
let currentPaperSize = "A4"; // 現在の用紙サイズ
let currentPrintMode = "drawOnly"; // 現在の印刷モード（デフォルト：描画モード）
let currentVideoSize = 100; // 現在のビデオサイズ（デフォルト100%）
let canvasScale = 0.7; // キャンバススケール
let animationStartWaitTime = 3.3; // アニメーション開始待機時間
let rotationWaitTime = 7.5; // 回転後待機時間
let currentPenThickness = 6; // 現在のペンの太さ（細い）
let currentPenColor = 'black'; // 現在のペンの色
let hasSentData = false; // 送信済みフラグ
// WriterID別の描画状態管理（書き手側用）
const writerDrawingStates = {};

// 現在の書き手用のレガシー変数（後方互換性のため保持）
let lastPosition = null; // 前回の位置を記録
let currentPath = []; // 現在のストロークのポイント配列
// [削除] smoothingFactor - 未使用変数を削除

// ベジェ曲線補間用の点履歴
let pointHistory = []; // 最新3点を保持してベジェ曲線を描画
const MAX_POINT_HISTORY = 3; // 保持する点の最大数
let starEffectEnabled = true; // 星エフェクトの有効/無効（標準でON）
let fairyDustEffectEnabled = true; // 妖精の粉エフェクトの有効/無効（標準でON）
let heartEffectEnabled = false; // ハートエフェクトの有効/無効（標準でOFF）
let penSoundEnabled = false; // ペン音の有効/無効（標準でOFF）
let specialBackgroundState = 'ready'; // 'ready', 'door_shown', 'door_opened'
let specialBackgroundToggle = false; // 特殊背景の画像を切り替えるフラグ

// 🎬 送信側動画背景関連変数
let senderVideoElement = null;
let isSenderVideoActive = false;

// 🎵 ペン音制御
let drawingAudio = null; // 描画中の音楽オブジェクト
let isDrawingActive = false; // 描画中フラグ
let drawingInactiveTimer = null; // 描画停止タイマー
const DRAWING_PAUSE_DELAY = 500; // 描画停止から一時停止までの遅延（ミリ秒）

// 🔍 背景デバッグ表示制御
let backgroundDebugEnabled = false;
let lastBackgroundSrc = null;

// 背景別キャンバスサイズ設定（1.02倍サイズ = 0.6*1.7）
const backgroundSizes = {
  'back3': { width: 859, height: 607 },    // 背景1 - 統一アスペクト比 (859/607 ≈ 1.415)
  'back2': { width: 859, height: 607 },    // 背景2 - 統一アスペクト比に変更
  'back4': { width: 859, height: 607 },    // 背景3 - 統一アスペクト比
  'back5': { width: 859, height: 607 },    // 背景5 - 統一アスペクト比
  'back6': { width: 859, height: 607 },    // 背景4 - 統一アスペクト比
  'white': { width: 859, height: 607 }     // 白背景 - 統一アスペクト比
};

// 🚀 非侵入的パフォーマンス最適化レイヤー
// 既存機能を一切変更せず、追加のみで最適化
let performanceOptimizer = {
  lastMouseTime: 0,
  lastTouchTime: 0,
  pendingEffects: [],
  effectAnimationId: null,
  MOUSE_THROTTLE_INTERVAL: 16, // PC用: 60fps相当
  TOUCH_THROTTLE_INTERVAL: 8,  // Redmi Pad 2軽量化: 360Hz→120Hz相当（125fps）
  
  // マウスイベントのスロットリングチェック（PC用）
  shouldProcessMouseEvent() {
    const now = Date.now();
    if (now - this.lastMouseTime < this.MOUSE_THROTTLE_INTERVAL) {
      return false;
    }
    this.lastMouseTime = now;
    return true;
  },
  
  // タッチイベントのスロットリングチェック（Redmi Pad 2最適化）
  shouldProcessTouchEvent() {
    const now = Date.now();
    if (now - this.lastTouchTime < this.TOUCH_THROTTLE_INTERVAL) {
      return false;
    }
    this.lastTouchTime = now;
    return true;
  },
  
  // エフェクト処理の遺延実行
  scheduleEffect(effectFunction) {
    this.pendingEffects.push(effectFunction);
    if (!this.effectAnimationId) {
      this.effectAnimationId = requestAnimationFrame(() => {
        // エフェクトをバッチ処理
        for (const effect of this.pendingEffects) {
          if (Math.random() < 0.3) { // 30%の確率で実行（パフォーマンス調整）
            effect();
          }
        }
        this.pendingEffects = [];
        this.effectAnimationId = null;
      });
    }
  }
};

socket.onopen = () => {
  console.log("✅ WebSocket接続完了（送信側）");
  
  // 少し待ってからwriter ID を要求（受信側の準備完了を待つ）
  setTimeout(() => {
    console.log("🔄 WriterID要求を開始");
    requestWriterId();
    
    // 初期背景画像の設定はWriterID割り当て完了後に実行するため、ここでは削除
    console.log('⏳ WriterID割り当て待ち - 背景画像送信はWriterID取得後に実行');
  }, 500);
};

socket.onmessage = (event) => {
  try {
    let data;
    
    // Blobの場合は文字列として読み取る
    if (event.data instanceof Blob) {
      const reader = new FileReader();
      reader.onload = function() {
        try {
          data = JSON.parse(reader.result);
          processMessage(data);
        } catch (error) {
          console.error('❌ Blobデータの解析エラー:', error);
        }
      };
      reader.readAsText(event.data);
      return;
    } else {
      // 文字列の場合
      data = JSON.parse(event.data);
      processMessage(data);
    }
  } catch (error) {
    console.error('❌ メッセージ処理エラー:', error);
  }
};

// 不要なコントロール表示機能を削除 - シンプルなUIに統一

// デバイス検出と機能切り替えシステム
const DeviceManager = {
  // デバイスタイプを検出
  detectDevice() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    const touchSupport = 'ontouchstart' in window;
    const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;
    const maxTouchPoints = navigator.maxTouchPoints || 0;
    
    // タブレット判定
    const isTablet = (
      touchSupport &&
      maxTouchPoints > 1 &&
      (screenWidth >= 768 || screenHeight >= 768) &&
      (screenWidth <= 1024 || screenHeight <= 1024)
    ) || (
      /iPad|Android(?!.*Mobile)|Tablet/i.test(userAgent)
    );
    
    // スマートフォン判定
    const isMobile = (
      touchSupport &&
      !isTablet &&
      /Android|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)
    );
    
    // PC判定（デフォルト）
    const isPC = !isTablet && !isMobile;
    
    return {
      isPC,
      isTablet,
      isMobile,
      touchSupport,
      screenWidth,
      screenHeight,
      maxTouchPoints,
      userAgent: userAgent.substring(0, 100) // ログ用に短縮
    };
  },
  
  // デバイス別設定を適用
  applyDeviceSettings() {
    const device = this.detectDevice();
    console.log('🔍 デバイス検出結果:', device);
    
    if (device.isPC) {
      this.applyPCSettings();
    } else if (device.isTablet) {
      this.applyTabletSettings();
    } else if (device.isMobile) {
      this.applyMobileSettings();
    }
    
    return device;
  },
  
  // PC用設定
  applyPCSettings() {
    console.log('💻 PC設定を適用');
    
    // PC用の特別な設定
    const canvas = document.getElementById('drawCanvas');
    if (canvas) {
      // PCではマウス操作を最適化
      canvas.style.cursor = 'crosshair';
    }
    
    // PC用UIの調整
    document.body.classList.add('device-pc');
    document.body.classList.remove('device-tablet', 'device-mobile');
    
    // PC専用機能を有効化
    this.enablePCFeatures();
  },
  
  // タブレット用設定
  applyTabletSettings() {
    console.log('📱 タブレット設定を適用');
    
    // タブレット用の特別な設定
    const canvas = document.getElementById('drawCanvas');
    if (canvas) {
      // タブレットではタッチ操作を最適化
      canvas.style.cursor = 'none'; // カーソル非表示
    }
    
    // タブレット用UIの調整
    document.body.classList.add('device-tablet');
    document.body.classList.remove('device-pc', 'device-mobile');
    
    // タブレット専用機能を有効化
    this.enableTabletFeatures();
  },
  
  // モバイル用設定
  applyMobileSettings() {
    console.log('📱 モバイル設定を適用');
    
    // モバイル用の特別な設定
    const canvas = document.getElementById('drawCanvas');
    if (canvas) {
      canvas.style.cursor = 'none';
    }
    
    // モバイル用UIの調整
    document.body.classList.add('device-mobile');
    document.body.classList.remove('device-pc', 'device-tablet');
    
    // モバイル専用機能を有効化
    this.enableMobileFeatures();
  },
  
  // PC専用機能
  enablePCFeatures() {
    // PC用の詳細なDevToolsを表示
    const devButton = document.getElementById('devButton');
    if (devButton) {
      devButton.style.display = 'block';
    }
    
    // PC用のキーボードショートカットを有効化
    this.enableKeyboardShortcuts();
  },
  
  // タブレット専用機能
  enableTabletFeatures() {
    // タブレット用の大きなボタン
    const buttons = document.querySelectorAll('button');
    buttons.forEach(btn => {
      if (!btn.classList.contains('color-btn') && !btn.classList.contains('thickness-btn')) {
        btn.style.minHeight = '50px';
        btn.style.fontSize = '16px';
      }
    });
    
    // タブレット用のタッチ最適化
    this.optimizeForTouch();
  },
  
  // モバイル専用機能
  enableMobileFeatures() {
    // モバイル用の超大きなボタン
    const buttons = document.querySelectorAll('button');
    buttons.forEach(btn => {
      if (!btn.classList.contains('color-btn') && !btn.classList.contains('thickness-btn')) {
        btn.style.minHeight = '60px';
        btn.style.fontSize = '18px';
      }
    });
    
    // DevToolsを非表示（画面が小さいため）
    const devButton = document.getElementById('devButton');
    if (devButton) {
      devButton.style.display = 'none';
    }
  },
  
  // キーボードショートカット（PC専用）
  enableKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 'z':
            e.preventDefault();
            // Undo機能（将来実装）
            console.log('⌨️ Undo shortcut (PC only)');
            break;
          case 's':
            e.preventDefault();
            // Save機能
            console.log('⌨️ Save shortcut (PC only)');
            break;
        }
      }
    });
  },
  
  // タッチ最適化（タブレット/モバイル専用）
  optimizeForTouch() {
    // タッチ遅延を削除
    const style = document.createElement('style');
    style.textContent = `
      .device-tablet button, .device-mobile button {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        touch-action: manipulation;
      }
      
      .device-tablet .pen-controls, .device-mobile .pen-controls {
        gap: 15px;
      }
    `;
    document.head.appendChild(style);
  }
};
socket.onerror = (error) => console.error("❌ WebSocketエラー（送信側）:", error);
socket.onclose = (event) => {
  console.log("⚠️ WebSocket切断（送信側）:", event.code, event.reason);
  console.log("🧹 切断前の状態:", { myWriterId, mySessionId });
  
  // 接続切断時にセッション情報をリセット
  mySessionId = null;
  myWriterId = null;
  console.log("🧹 WebSocket切断に伴いセッション情報をリセット");
  
  // Writer ID表示をクリア
  const statusDiv = document.getElementById('writerStatus');
  if (statusDiv) {
    statusDiv.childNodes[0].textContent = 'Writer ID: 未割り当て';
  }
  document.title = '送信側 - 未接続';
};

// ハートエフェクト生成関数

let senderLKeyCount = 0;
let senderLKeyTimer = null;

document.addEventListener('keydown', function(event) {
  if (event.key.toLowerCase() === 'l') {
    senderLKeyCount++;
    // 送信側lキー押下
    
    if (senderLKeyTimer) {
      clearTimeout(senderLKeyTimer);
    }
    
    if (senderLKeyCount >= 10) {
      createSpecialHeart();
      senderLKeyCount = 0;
    } else {
      createHeart();
    }
    
    senderLKeyTimer = setTimeout(() => {
      senderLKeyCount = 0;
    }, 3000);
  }
});

setTimeout(() => {
  // テスト: 自動ハート表示
  createHeart();
}, 5000);

// 🔸 用紙サイズ設定関数

// 🖨️ 印刷モード設定関数

// 🔸 キャンバスサイズ変更関数を追加

function startCountdown() {
  const countdownEl = document.getElementById("countdown");
  
  // 🔸 用紙サイズに応じてカウントダウン時間を調整
  let totalSeconds;
  if (currentPaperSize === "poster") {
    totalSeconds = 8; // ポスター：3秒短縮（11秒→8秒）
  } else if (currentPaperSize === "L") {
    totalSeconds = 9; // L判：2秒短縮（11秒→9秒）
  } else {
    totalSeconds = 11; // A4：従来通り11秒
  }
  
  let seconds = totalSeconds;
  countdownEl.textContent = `お渡しまで：${seconds}秒`;
  
  const timer = setInterval(() => {
    seconds--;
    if (seconds >= 0) {
      countdownEl.textContent = `お渡しまで：${seconds}秒`;
    } else {
      clearInterval(timer);
      countdownEl.textContent = "";
      // ✅ カウントダウン終了後、筆跡のみ削除（背景維持）
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (backgroundImage) {
        drawBackgroundImage(ctx, backgroundImage, canvas);
      }
      
      // 描画コマンドをクリア
      drawingCommands = [];
      
      // ✅ 背景の同期送信
      const bgSrc = backgroundImage ? backgroundImage.src : "white";
      socket.send(JSON.stringify({ type: "clear" }));
      socket.send(JSON.stringify({ type: "background", src: bgSrc, writerId: myWriterId }));
    }
  }, 1000);
}

// ペンの太さ設定関数

// ペンの色設定関数

// 16進数カラーをRGBに変換
// 星エフェクトのON/OFF切り替え

// 🎵 ペン音制御関数（送信側では無効化）
// 描画用ハートを生成する関数
// createDrawingHeart, createSenderStar, createFairyDust, createStar

// 確実にイベントリスナーを追加するため、DOMが完全に読み込まれてから実行
document.addEventListener('DOMContentLoaded', function() {
  const canvasElement = document.getElementById('drawCanvas');
  
  if (canvasElement) {
    
    // 標準的なペイントツール方式の描画システム
    // isPaintDrawing、lastPaintPos、getBackgroundArea、isWithinBackgroundAreaはグローバルで定義済み
    
    // 共通関数: キャンバス座標を取得
    function getCanvasCoordinates(event, element) {
      const rect = element.getBoundingClientRect();
      const scaleX = element.width / rect.width;
      const scaleY = element.height / rect.height;
      const x = (event.clientX - rect.left) * scaleX;
      const y = (event.clientY - rect.top) * scaleY;
      return { x, y };
    }
    
    // 共通関数: タッチイベント用キャンバス座標を取得
    function getTouchCanvasCoordinates(event, element) {
      const touch = event.touches[0];
      const rect = element.getBoundingClientRect();
      const scaleX = element.width / rect.width;
      const scaleY = element.height / rect.height;
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      return { x, y };
    }
    
    // 共通関数: 描画設定を初期化
    function setupDrawingContext() {
      ctx.strokeStyle = currentPenColor || 'black';
      ctx.lineWidth = currentPenThickness || 8;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
    }
    
    // 共通関数: 描画開始メッセージを作成
    function createStartMessage(x, y) {
      return {
        type: "start",
        x: x,
        y: y,
        thickness: currentPenThickness,
        color: currentPenColor,
        writerId: myWriterId,
        timestamp: Date.now()
      };
    }
    
    // 共通関数: 描画継続メッセージを作成
    function createDrawMessage(x, y) {
      return {
        type: "draw",
        x: x,
        y: y,
        thickness: currentPenThickness,
        color: currentPenColor,
        writerId: myWriterId,
        timestamp: Date.now(),
        starEffect: starEffectEnabled,
        fairyDustEffect: fairyDustEffectEnabled,
        canvasSize: {
          width: canvas.width,
          height: canvas.height
        }
      };
    }
    
    // 共通関数: 統合描画開始処理
    function handleDrawingStart(x, y) {
      // 背景画像の範囲内かチェック
      if (!isWithinBackgroundArea(x, y)) {
        console.log('🖱️ 背景画像範囲外のためスキップ');
        return false;
      }
      
      // 共通フラグ設定
      drawing = true;
      isPaintDrawing = true;
      lastPaintPos = { x, y };
      lastPosition = { x, y };
      
      // ベジェ曲線用の点履歴をリセット
      pointHistory = [{ x, y }];
      currentPath = [{ x, y }];
      
      // WriterID別描画状態をリセット
      resetWriterDrawingState('self');
      const selfState = getWriterDrawingState('self');
      selfState.lastPosition = { x, y };
      selfState.currentPath = [{ x, y }];
      selfState.isDrawing = true;
      
      // Canvas状態を完全に初期化
      // コンテキスト初期化と描画設定を統合
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalCompositeOperation = 'source-over';
      ctx.shadowBlur = 0;
      ctx.shadowColor = 'transparent';
      ctx.globalAlpha = 1.0;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      setupDrawingContext();
      
      // 描画開始（最適化：1回のbeginPath()で処理）
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + 0.1, y + 0.1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
      
      // 描画コマンドを記録
      const startCmd = {
        type: "start",
        x: x,
        y: y,
        thickness: currentPenThickness,
        color: currentPenColor === 'black' ? '#000' : currentPenColor
      };
      drawingCommands.push(startCmd);
      
      // Writer IDチェック
      if (!myWriterId) {
        console.warn("⚠️ Writer ID未設定のため描画データを送信しません");
        return true; // 描画は開始したがWebSocket送信はしない
      }
      
      // WebSocket送信
      const startMsg = createStartMessage(x, y);
      startMsg.starEffect = starEffectEnabled;
      startMsg.fairyDustEffect = fairyDustEffectEnabled;
      startMsg.heartEffect = heartEffectEnabled;
      startMsg.canvasSize = { width: canvas.width, height: canvas.height };
      
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(startMsg));
      }
      
      // エフェクト生成
      const rect = canvas.getBoundingClientRect();
      const pageX = rect.left + x;
      const pageY = rect.top + y;
      
      if (starEffectEnabled) {
        createSenderStar(pageX, pageY);
      }
      if (fairyDustEffectEnabled) {
        createFairyDust(pageX, pageY);
      }
      
      return true;
    }
    
    // 共通関数: 統合描画継続処理
    function handleDrawingMove(x, y) {
      if (!drawing || !isPaintDrawing) return;
      
      // 背景画像の範囲内かチェック
      if (!isWithinBackgroundArea(x, y)) {
        console.log('🖱️ 背景画像範囲外 - 描画中断');
        drawing = false;
        isPaintDrawing = false;
        lastPaintPos = null;
        return;
      }
      
      // 線を描画
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
      
      // パス更新
      currentPath.push({ x, y });
      lastPosition = { x, y };
      
      // 点履歴更新（ベジェ曲線用）
      pointHistory.push({ x, y });
      if (pointHistory.length > MAX_POINT_HISTORY) {
        pointHistory.shift();
      }
      
      // 描画コマンド記録
      const actualColor = currentPenColor === 'white-red-border' ? '#ffffff' : 
                         (currentPenColor === 'black' ? '#000' : 
                         (currentPenColor === 'white' ? '#fff' : 
                         (currentPenColor === 'green' ? '#008000' : 
                         (currentPenColor === 'pink' ? '#ff69b4' : currentPenColor))));
      const drawCmd = {
        type: "draw",
        x: x,
        y: y,
        thickness: currentPenThickness,
        color: actualColor
      };
      drawingCommands.push(drawCmd);
      
      // WebSocket送信
      if (myWriterId) {
        const drawMsg = createDrawMessage(x, y);
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify(drawMsg));
        }
      }
      
      // エフェクト生成
      const rect = canvas.getBoundingClientRect();
      const pageX = rect.left + x;
      const pageY = rect.top + y;
      
      if (starEffectEnabled && Math.random() < 0.5) {
        createSenderStar(pageX, pageY);
      }
      if (fairyDustEffectEnabled && Math.random() < 0.3) {
        createFairyDust(pageX, pageY);
      }
      
      lastPaintPos = { x, y };
    }
    
    // 共通関数: 統合描画終了処理
    function handleDrawingEnd() {
      drawing = false;
      isPaintDrawing = false;
      
      // ベジェ曲線用の点履歴をクリア
      pointHistory = [];
      
      // WriterID別描画状態を更新
      const selfState = getWriterDrawingState('self');
      if (selfState) {
        selfState.isDrawing = false;
      }
      
      // white-red-border の特別処理
      if (currentPenColor === 'white-red-border' && currentPath.length > 1) {
        drawWhiteRedBorderEffect();
      }
      
      // パスをクリア
      currentPath = [];
      lastPaintPos = null;
      lastPosition = null;
    }
    
    // 共通関数: white-red-border エフェクト
    function drawWhiteRedBorderEffect() {
      ctx.save();
      
      // 描画レイヤー定義（外側→内側の順）
      const layers = [
        { thickness: currentPenThickness + 10, alpha: 0.2, color: '#ffccdd' },
        { thickness: currentPenThickness + 8, alpha: 0.5, color: '#ffaacc' },
        { thickness: currentPenThickness + 6, alpha: 0.8, color: '#ff88bb' },
        { thickness: Math.max(1, currentPenThickness - 3), alpha: 0.9, color: '#ffffff' }
      ];
      
      // 共通設定
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // 各レイヤーを効率的に描画
      layers.forEach(layer => {
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        ctx.lineWidth = layer.thickness;
        ctx.globalAlpha = layer.alpha;
        ctx.strokeStyle = layer.color;
        ctx.shadowColor = layer.color;
        
        for (let i = 1; i < currentPath.length; i++) {
          ctx.lineTo(currentPath[i].x, currentPath[i].y);
        }
        ctx.stroke();
      });
      
      ctx.restore();
    }
    
    // PointerEventsを使用（より確実なイベント処理）
    if ('PointerEvent' in window) {
      
      canvasElement.addEventListener('pointerdown', (e) => {
        const { x, y } = getCanvasCoordinates(e, canvasElement);
        handleDrawingStart(x, y);
      });
      
      canvasElement.addEventListener('pointermove', (e) => {
        const { x, y } = getCanvasCoordinates(e, canvasElement);
        handleDrawingMove(x, y);
      });
      
      canvasElement.addEventListener('pointerup', (e) => {
        handleDrawingEnd();
      });
      
    } else {
      console.log('🖱️ 従来のマウスイベントを使用');
      
      // 従来のマウスイベント（フォールバック）
      canvasElement.addEventListener('mousedown', (e) => {
        console.log('🖱️ mousedown - 描画開始');
        const { x, y } = getCanvasCoordinates(e, canvasElement);
        handleDrawingStart(x, y);
        e.preventDefault();
      });
      
      canvasElement.addEventListener('mousemove', (e) => {
        const { x, y } = getCanvasCoordinates(e, canvasElement);
        handleDrawingMove(x, y);
      });
      
      canvasElement.addEventListener('mouseup', (e) => {
        console.log('🖱️ mouseup - 描画終了');
        handleDrawingEnd();
      });
    }
    
    // 統合タッチイベント処理
    canvasElement.addEventListener("touchstart", (e) => {
      e.preventDefault();
      console.log('📱 touchstart - 統合描画開始');
      const { x, y } = getTouchCanvasCoordinates(e, canvasElement);
      handleDrawingStart(x, y);
    });
    
    canvasElement.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const { x, y } = getTouchCanvasCoordinates(e, canvasElement);
      handleDrawingMove(x, y);
    });
    
    canvasElement.addEventListener("touchend", (e) => {
      e.preventDefault();
      console.log('📱 touchend - 統合描画終了');
      handleDrawingEnd();
    });
    
    // mouseleaveで描画を終了（一般的なペイントツールの動作）
    canvasElement.addEventListener("mouseleave", (e) => {
      console.log('🖱️ mouseleave - 描画終了');
      handleDrawingEnd();
    });
    
    // 右クリックで描画を中断
    canvasElement.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      console.log('🖱️ 右クリック - 描画中断');
      handleDrawingEnd();
    });
  }
});



// [重複削除] 古いmousemove/touchイベントリスナーブロックを削除 (統合版を使用)
// [重複削除] 古いtouchmoveイベントリスナーブロックを削除 (統合版を使用)

// 🔸 UI制御関数群 (setVideoSize, playVideo) はui-controls.jsに移動しました

// 🔧 Dev Tools関数群 (toggleDevTools, updateCanvasScale, updateAnimationStartWait, updateRotationWait, sendDevSettings) はdev-tools.jsに移動しました

// 描画データを保存する配列
let drawingCommands = [];

function saveRotatedImage() {
  
  try {
    // 最終的な画像用のcanvasを作成
    const finalCanvas = document.createElement('canvas');
    const finalCtx = finalCanvas.getContext('2d');
    finalCanvas.width = canvas.width;
    finalCanvas.height = canvas.height;
    
    // 1. 背景を先に描画（回転させない）
    if (backgroundImage) {
      finalCtx.drawImage(backgroundImage, 0, 0, finalCanvas.width, finalCanvas.height);
    } else {
      // 白背景で塗りつぶし
      finalCtx.fillStyle = '#ffffff';
      finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
    }
    
    // 2. ペイントデータのみを180度回転させて描画
    if (drawingCommands.length > 0) {
      
      // 180度回転変換を適用
      finalCtx.save();
      finalCtx.translate(finalCanvas.width, finalCanvas.height);
      finalCtx.rotate(Math.PI);
      
      // 描画コマンドを実行（座標は元のまま、キャンバスが回転している）
      drawingCommands.forEach(cmd => {
        if (cmd.type === 'start') {
          finalCtx.beginPath();
          finalCtx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'draw') {
          finalCtx.lineWidth = cmd.thickness || 8;
          finalCtx.strokeStyle = cmd.color || 'black';
          finalCtx.lineTo(cmd.x, cmd.y);
          finalCtx.stroke();
        }
      });
      
      finalCtx.restore();
    } else {
    }
    
    // 自動ダウンロード
    const imageDataUrl = finalCanvas.toDataURL('image/png');
    const link = document.createElement('a');
    const now = new Date();
    const fileName = `rotated_${now.getFullYear()}${(now.getMonth() + 1)
      .toString().padStart(2, "0")}${now.getDate().toString().padStart(2, "0")}_${now
      .getHours().toString().padStart(2, "0")}${now.getMinutes().toString().padStart(2, "0")}${now
      .getSeconds().toString().padStart(2, "0")}.png`;
    
    link.download = fileName;
    link.href = imageDataUrl;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    
  } catch (error) {
    console.error('❌ 180度回転画像保存エラー詳細:', error.message, error);
    alert('画像の保存に失敗しました: ' + error.message);
  }
}

// 現在の状態から更に180度回転させて保存する関数
function saveDoubleRotatedImage() {
  // 音楽制御は送信側では無効化（受信側のみで音楽再生）
  
  console.log(`🔄🔄🔄 送信ボタン押下: globalSend送信開始→${animationStartWaitTime}秒後にアニメーション開始 🔄🔄🔄`);
  
  // 🔸 まず受信側に印刷指示を送信（データが残っている状態で）
  console.log('📤📤📤 受信側にglobalSend指示を送信中... 📤📤📤');
  socket.send(JSON.stringify({
    type: "globalSend",
    writerId: myWriterId,
    timestamp: Date.now(),
    animationStartWaitTime: animationStartWaitTime,
    rotationWaitTime: rotationWaitTime
  }));
  console.log('✅✅✅ 受信側へのglobalSend指示送信完了 ✅✅✅');
  
  // 🔸 少し待ってから送信側の印刷処理のみ実行
  setTimeout(() => {
    actualPrintProcess();
  }, 500); // 受信側の印刷処理が開始されるまで500ms待機
  
  // 🔄 送信直後に新しい描画を可能にするため、hasSentDataフラグを即座にリセット
  // 送信済みフラグをリセットして、すぐに新しい描画を可能にする
  hasSentData = false;
  console.log('🔓 送信直後: hasSentDataをリセット - 新しい描画と他writerデータ受信を再開');
  
  // 🔄 受信側のアニメーション完了後に送信者側のデータクリアと自動Clear処理を実行
  const totalAnimationTime = (animationStartWaitTime + 1 + rotationWaitTime + 2) * 1000; // アニメーション開始待機 + 回転1秒 + 回転後待機 + スライド2秒
  console.log(`🔄 送信完了 → ${totalAnimationTime/1000}秒後（アニメーション完了後）に送信者データクリア + 自動Clear処理を実行`);
  setTimeout(() => {
    // 🔸 送信者側のデータクリア（アニメーション完了後）
    otherWritersData = {};
    drawingCommands = []; // 🔥 アニメーション完了後に自分の描画コマンドをクリア
    console.log('🧹 アニメーション完了後: 全描画データをクリア');
    console.log('🧹 otherWritersData遅延クリア:', Object.keys(otherWritersData).length);
    console.log('🧹 drawingCommands遅延クリア:', drawingCommands.length);
    
    // キャンバスを再描画（空の状態）- 遅延実行
    if (window.saveDoubleRotatedRedrawTimeout) {
      clearTimeout(window.saveDoubleRotatedRedrawTimeout);
    }
    
    window.saveDoubleRotatedRedrawTimeout = setTimeout(() => {
      redrawCanvasWithOthers();
      window.saveDoubleRotatedRedrawTimeout = null;
    }, 10);
    
    // 全書き手同期のためのクリア命令を送信
    socket.send(JSON.stringify({ 
      type: "globalClear",
      writerId: myWriterId,
      timestamp: Date.now()
    }));
    console.log('📤 自動Clear: 全書き手にクリア指示を送信');
    console.log('✅ 自動Clear処理完了（アニメーション完了後）');
  }, totalAnimationTime); // アニメーション完了後に自動Clear実行
  
  // 🔸 送信ボタンの視覚的フィードバック
  const sendButton = event.target;
  sendButton.style.transform = 'scale(0.95)';
  sendButton.style.backgroundColor = '#ff1493';
  sendButton.style.color = '#fff';
  sendButton.textContent = '送信中...';
  sendButton.disabled = true;
  
  // 🔸 打ち上げ花火演出を追加（受信側と同期）
  // 回転アニメーション完了後1秒で実行するようにタイミング調整
  const fireworksCheckbox = document.getElementById('fireworksEffect');
  if (fireworksCheckbox.checked) {
    const fireworksDelay = animationStartWaitTime * 1000 + 2500; // アニメーション開始待機時間 + 回転時間(1.5秒) + 1秒
    setTimeout(() => {
      createFireworks();
    }, fireworksDelay);
  } else {
  }
  
  // 🔸 紙吹雪演出を追加（受信側と同期）
  const confettiCheckbox = document.getElementById('confettiEffect');
  if (confettiCheckbox.checked) {
    const confettiDelay = animationStartWaitTime * 1000 + 2500 + (rotationWaitTime * 1000) - 1500; // 花火と同じタイミング + 回転後待機時間 - 1.5秒前
    setTimeout(() => {
      createConfetti();
    }, confettiDelay);
  } else {
  }
  
  // ボタンを元に戻す
  setTimeout(() => {
    sendButton.style.transform = 'scale(1)';
    sendButton.style.backgroundColor = '';
    sendButton.style.color = '';
    sendButton.textContent = '送信';
    sendButton.disabled = false;
  }, 2000);
  
  // 🔸 印刷処理は既に上で実行済み
  
  // 🔸 印刷処理開始の設定時間後に回転アニメーションを開始
  
  // 設定時間後にWebSocket経由で受信側にアニメーション開始を通知
  setTimeout(() => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        type: "startRotationAnimation",
        waitTime: rotationWaitTime, // 回転後待機時間を設定値から取得
        fireworksEnabled: document.getElementById('fireworksEffect').checked,
        confettiEnabled: document.getElementById('confettiEffect').checked
      }));
    }
  }, animationStartWaitTime * 1000); // アニメーション開始待機時間（秒をミリ秒に変換）
  
  // 🔸 送信ボタン押下から10秒後にクリアを実行（印刷が即座に開始されるため）
  setTimeout(() => {
    
    // 🔒 送信済みフラグは維持（手動でClearボタンを押すまで他のwriterデータを受信しない）
    // hasSentData = false; // この行をコメントアウト
    
    // キャンバスを完全にクリア
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 背景画像があれば再描画（回転なし）
    if (backgroundImage) {
      drawBackgroundImage(ctx, backgroundImage, canvas);
    }
    
    // 全ての描画データを完全クリア
    drawingCommands = [];
    otherWritersData = {};
    
    // 受信側にもクリア指示を送信
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "clear" }));
    }
    
  }, 10000); // 送信ボタン押下から10秒後にクリア
}

// 実際の印刷処理を行う関数
function actualPrintProcess() {
  try {
    // 新しいcanvasを作成（taintedにならないように）
    const cleanCanvas = document.createElement('canvas');
    const cleanCtx = cleanCanvas.getContext('2d');
    cleanCanvas.width = canvas.width;
    cleanCanvas.height = canvas.height;
    
    // 白背景で塗りつぶし（背景画像は使わない）
    cleanCtx.fillStyle = '#ffffff';
    cleanCtx.fillRect(0, 0, cleanCanvas.width, cleanCanvas.height);
    
    // 保存された描画コマンドを再実行（360度回転 = 元の向き）
    if (drawingCommands.length > 0) {
      
      // 描画コマンドを実行（回転なし = 元の向き）
      drawingCommands.forEach(cmd => {
        if (cmd.type === 'start') {
          cleanCtx.beginPath();
          cleanCtx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'draw') {
          cleanCtx.lineWidth = cmd.thickness || 8;
          cleanCtx.strokeStyle = cmd.color || 'black';
          cleanCtx.lineTo(cmd.x, cmd.y);
          cleanCtx.stroke();
        }
      });
      
    } else {
      // 描画データがない場合は何もしない
    }
    
    // 自動印刷処理
    const imageDataUrl = cleanCanvas.toDataURL('image/png');
    
    // WebSocket経由で受信側に印刷指示を送信
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        type: "printRotatedImage",
        imageData: imageDataUrl,
        printType: 'double_rotated',
        paperSize: currentPaperSize,
        printMode: currentPrintMode,
        switchBotEnabled: document.getElementById('switchBotEffect').checked
      }));
    } else {
      // フォールバック: ダウンロード
      const link = document.createElement('a');
      const now = new Date();
      const fileName = `double_rotated_${now.getFullYear()}${(now.getMonth() + 1)
        .toString().padStart(2, "0")}${now.getDate().toString().padStart(2, "0")}_${now
        .getHours().toString().padStart(2, "0")}${now.getMinutes().toString().padStart(2, "0")}${now
        .getSeconds().toString().padStart(2, "0")}.png`;
      
      link.download = fileName;
      link.href = imageDataUrl;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
    }
    
    
  } catch (error) {
    console.error('❌ 更に180度回転画像保存エラー詳細:', error.message, error);
    alert('更に180度回転画像の保存に失敗しました: ' + error.message);
  }
}

// 🧪 テスト・テーマ関数群 (testSwitchBot, toggleTheme) はui-controls.jsに移動しました

// 背景画像の変形パラメータ
let backgroundScale = 1.0; // スケール（大きさ）
let backgroundOffsetY = 0; // 垂直オフセット

// 🎯 イベントハンドラー・初期化処理 (キーボードイベント, DOMContentLoaded, タッチイベント) はevent-handlers.jsに移動しました
</script>
</div>

<div class="color-panel">
  <h3>ペンの色</h3>
  <button class="color-btn selected" style="background: black;" onclick="setPenColor('black')"></button>
  <button class="color-btn" style="background: red;" onclick="setPenColor('red')"></button>
  <button class="color-btn" style="background: blue;" onclick="setPenColor('blue')"></button>
  <button class="color-btn" style="background: green;" onclick="setPenColor('green')"></button>
  <button class="color-btn" style="background: white; border: 4px solid red; box-sizing: border-box;" onclick="setPenColor('white-red-border')"></button>
</div>

<div class="thickness-panel">
  <h3>ペンの太さ</h3>
  <button class="thickness-btn" onclick="setPenThickness(10)" title="太い (+30%)">
    <div style="width: 21px; height: 21px; border-radius: 50%; background: #333; flex-shrink: 0;"></div>
  </button>
  <button class="thickness-btn selected" onclick="setPenThickness(8)" title="標準">
    <div style="width: 16px; height: 16px; border-radius: 50%; background: #333; flex-shrink: 0;"></div>
  </button>
  <button class="thickness-btn" onclick="setPenThickness(6)" title="細い (-25%)">
    <div style="width: 12px; height: 12px; border-radius: 50%; background: #333; flex-shrink: 0;"></div>
  </button>
  <button class="thickness-btn" onclick="setPenThickness(4)" title="とても細い (-50%)">
    <div style="width: 8px; height: 8px; border-radius: 50%; background: #333; flex-shrink: 0;"></div>
  </button>
</div>

<!-- タブレット用の重複コントロールを削除 - シンプルUI -->

</div>

<!-- 視覚エフェクト機能を外部ファイルから読み込み -->
<script src="effects.js"></script>

<!-- 特殊エフェクト機能（ハート・花火・紙吹雪）を外部ファイルから読み込み -->
<script src="special-effects.js"></script>

<!-- 設定・ユーティリティ機能を外部ファイルから読み込み -->
<script src="settings.js"></script>

<!-- WebSocket・通信機能を外部ファイルから読み込み -->
<script src="websocket.js"></script>

<!-- 背景・キャンバス管理機能を外部ファイルから読み込み -->
<script src="canvas-background.js"></script>
<!-- 送信側動画機能を外部ファイルから読み込み -->
<script src="video-sender.js"></script>
<!-- 音楽・音声機能を外部ファイルから読み込み -->
<script src="audio-music.js"></script>
<!-- ユーティリティ・計算機能を外部ファイルから読み込み -->
<script src="utils.js"></script>
<!-- 描画ライン機能を外部ファイルから読み込み -->
<script src="drawing-lines.js"></script>
<!-- 開発ツール機能を外部ファイルから読み込み -->
<script src="dev-tools.js"></script>
<!-- UI制御・テーマ機能を外部ファイルから読み込み -->
<script src="ui-controls.js"></script>
<!-- イベントハンドラー・初期化機能を外部ファイルから読み込み -->
<script src="event-handlers.js"></script>

</body>
</html>
