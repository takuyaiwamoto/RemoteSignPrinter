<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' wss://realtime-sign-server-1.onrender.com ws://localhost:* wss://localhost:*; img-src 'self' data: blob:; media-src 'self';">
  <title>送信側v3.9-smooth</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="modern">
<button id="themeToggle" onclick="toggleTheme()">📝 クラシック</button>

<div class="main-container" style="display: flex; justify-content: center; align-items: flex-start; gap: 20px;">
<div class="canvas-container">
<div style="position: relative; display: inline-block; margin: 50px auto 20px auto;">
  <img src="back2.png" alt="背景画像" style="transform: scale(1.3); display: block;">
  <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: pink; transform: scale(1.3); transform-origin: center; pointer-events: none; z-index: 1;"></div>
  <canvas id="drawCanvas" width="283" height="420" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scale(1.3); transform-origin: center; cursor: crosshair; background: transparent; z-index: 10;"></canvas>
</div>

<!-- メインコントロール: Clear、自分だけ削除、送信 -->
<div class="main-controls" style="display: flex; align-items: center; gap: 15px;">
  <button onclick="clearCanvas()">Clear</button>
  <button onclick="clearMyDrawing()" style="background-color: #FF6B6B; color: white;">自分だけ消去</button>
  <button onclick="startWaitingAnimation()" style="background-color: #FF9800; color: white; font-size: 18px; padding: 12px 24px; font-weight: bold;">スタート</button>
  <button onclick="saveDoubleRotatedImage()" style="background-color: #4CAF50; color: white; font-size: 18px; padding: 12px 24px; font-weight: bold;">渡す</button>
  <div id="countdownTimer" style="font-size: 16px; font-weight: bold; color: #333; display: none; background-color: #FFF3CD; border: 2px solid #FFEAA7; border-radius: 8px; padding: 8px 12px;">
    <span id="countdownText">--秒</span>
  </div>
</div>

<!-- 透明ウィンドウと同期するカウントダウン表示 -->
<div id="syncCountdown" style="
  position: fixed;
  top: 20px;
  right: 50px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 15px 20px;
  border-radius: 10px;
  font-size: 24px;
  font-weight: bold;
  z-index: 9999;
  display: none;
">5</div>

<!-- 幕が閉じています表示 -->
<div id="curtainClosedDisplay" style="
  position: fixed;
  top: 20px;
  right: 50px;
  background: rgba(200, 50, 50, 0.9);
  color: white;
  padding: 15px 20px;
  border-radius: 10px;
  font-size: 18px;
  font-weight: bold;
  z-index: 9998;
  display: block;
">幕が閉じています</div>

<!-- スタートボタン上の「幕が上るまで」カウントダウン -->
<div id="curtainCountdown" style="
  position: absolute;
  background: rgba(255, 255, 255, 0.95);
  color: #333;
  padding: 10px 15px;
  border-radius: 8px;
  border: 2px solid #FF9800;
  font-size: 16px;
  font-weight: bold;
  z-index: 10000;
  display: none;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
">
  <div style="font-size: 14px; color: #666;">幕が上るまで</div>
  <div id="curtainTimer" style="font-size: 28px; color: #FF9800; margin-top: 5px;">3</div>
</div>

<!-- 右サイドバー: ペンの色と太さを並べて配置 （Clearボタンの直下に移動） -->
<div class="right-sidebar" style="display: flex; gap: 15px; margin-top: 5px;">
  <!-- 左列: 色 -->
  <div class="pen-colors-vertical" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
    <h4 style="margin: 0; font-size: 16px; color: #333;">色</h4>
    <button class="color-btn selected" style="background: black; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('black')"></button>
    <button class="color-btn" style="background: red; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('red')"></button>
    <button class="color-btn" style="background: blue; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('blue')"></button>
    <button class="color-btn" style="background: green; width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc;" onclick="setPenColor('green')"></button>
  </div>
  
  <!-- 右列: 太さ -->
  <div class="pen-thickness-vertical" style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
    <h4 style="margin: 0; font-size: 16px; color: #333;">太さ</h4>
    <button class="thickness-btn" onclick="setPenThickness(10)" title="太い (+30%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 21px; height: 21px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn" onclick="setPenThickness(8)" title="標準" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 16px; height: 16px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn selected" onclick="setPenThickness(6)" title="細い (-25%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #333; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 12px; height: 12px; border-radius: 50%; background: #333;"></div>
    </button>
    <button class="thickness-btn" onclick="setPenThickness(4)" title="とても細い (-50%)" style="width: 50px; height: 50px; border-radius: 50%; border: 2px solid #ccc; background: white; display: flex; align-items: center; justify-content: center;">
      <div style="width: 8px; height: 8px; border-radius: 50%; background: #333;"></div>
    </button>
  </div>
</div>
</div>

<!-- 背景選択はDevToolに移動 -->
<div class="button-group">
  <button onclick="toggleDevTools()" style="background-color: #FFA500; color: white;">🔧 Dev Tool</button>
</div>

<div id="devTools" style="display: none; border: 2px solid orange; padding: 10px; margin-top: 10px;">
  <h3>開発者ツール</h3>
  
  <div class="button-group">
    <label>キャンバスサイズ調整:</label>
    <input type="range" id="canvasScale" min="0.1" max="3.0" step="0.05" value="1.4" oninput="updateCanvasScale(this.value)">
    <span id="canvasScaleValue">1.4x</span>
  </div>
  
  <div class="button-group">
    <label>アニメーション開始待機時間（秒）:</label>
    <input type="range" id="animationStartWait" min="0.1" max="10" step="0.1" value="0.1" oninput="updateAnimationStartWait(this.value)">
    <span id="animationStartWaitValue">0.1秒</span>
  </div>
  
  <div class="button-group">
    <label>回転後待機時間（秒）:</label>
    <input type="range" id="rotationWait" min="1" max="10" step="0.5" value="1.0" oninput="updateRotationWait(this.value)">
    <span id="rotationWaitValue">1.0秒</span>
  </div>
  
  <div class="button-group">
    <label>🎵 音楽ボリューム（背景5）:</label>
    <input type="range" id="musicVolume" min="0" max="1" step="0.05" value="0.5" oninput="updateMusicVolume(this.value)">
    <span id="musicVolumeValue">50%</span>
  </div>
  
  <div class="button-group">
    <label>🖨️ 印刷遅延時間（秒）:</label>
    <input type="range" id="printDelay" min="0" max="10" step="0.5" value="5.0" oninput="updatePrintDelay(this.value)">
    <span id="printDelayValue">5.0秒</span>
  </div>
  
  <div class="button-group">
    <label>背景5動画パターン:</label>
    <button id="pattern1Btn" onclick="setVideoPattern(1)" style="background: #4CAF50; color: white;">パターン1(回転)</button>
    <button id="pattern2Btn" class="selected" onclick="setVideoPattern(2)" style="background: #2196F3; color: white;">パターン2(フェード)</button>
  </div>
  
  <div class="button-group">
    <button onclick="sendDevSettings()">設定を受信側に送信</button>
  </div>
  
  <div class="button-group">
    <label>背景選択:</label>
    <button onclick="setBackground('./back3.png')">背景1</button>
    <button onclick="setBackground('./back2.png')">背景2</button>
    <button onclick="setBackground('./back4.png')">背景3</button>
    <button onclick="setBackground('./back6.png')">背景4</button>
    <button onclick="setBackgroundDev()" style="background: #ffc0cb;">背景5(dev)</button>
    <button onclick="setBackground(null)">白</button>
    <button onclick="setSpecialBackgroundToggle()" style="background: linear-gradient(45deg, #ff1493, #00ffff); color: white;">🎬 動画背景</button>
  </div>
  
  <hr style="margin: 15px 0;">
  
  <div class="button-group">
    <label>テスト演出:</label>
    <button onclick="createFireworks()" style="background: linear-gradient(45deg, #ff4500, #ffd700); color: white;">🎆 花火テスト</button>
    <button onclick="createConfetti()" style="background: linear-gradient(45deg, #ff69b4, #00fa9a); color: white;">🎊 紙吹雪テスト</button>
  </div>
  
  <div class="button-group">
    <label>ビデオサイズ:</label>
    <button id="size100Btn" class="selected" onclick="setVideoSize(100)">100%</button>
    <button id="size90Btn" onclick="setVideoSize(90)">90%</button>
    <button id="size80Btn" onclick="setVideoSize(80)">80%</button>
  </div>
  
  <div class="button-group">
    <button onclick="playVideo()" style="background-color: #FF6B6B; color: white;">📹 ビデオ再生</button>
  </div>
  
  <div class="button-group">
    <label>エフェクト:</label>
    <input type="checkbox" id="starEffect" onchange="toggleStarEffect()">
    <label for="starEffect">星</label>
    <input type="checkbox" id="fairyDustEffect" onchange="toggleFairyDustEffect()">
    <label for="fairyDustEffect">妖精の粉</label>
    <input type="checkbox" id="heartEffect" onchange="toggleHeartEffect()">
    <label for="heartEffect">💖 ハート</label>
    <input type="checkbox" id="penSoundEffect" onchange="togglePenSound()">
    <label for="penSoundEffect">🎵 ペン音</label>
  </div>
  
  <div class="button-group">
    <label>送信後演出:</label>
    <input type="checkbox" id="fireworksEffect" checked>
    <label for="fireworksEffect">🎆 花火</label>
    <input type="checkbox" id="confettiEffect" checked>
    <label for="confettiEffect">🎊 紙吹雪</label>
    <input type="checkbox" id="backgroundDebug" onchange="toggleBackgroundDebug()">
    <label for="backgroundDebug">🔍 背景デバッグ</label>
    <input type="checkbox" id="videoPlayback" checked onchange="toggleVideoPlayback()">
    <label for="videoPlayback">🎬 映像再生</label>
  </div>
  
  <div class="button-group">
    <label>用紙サイズ:</label>
    <button id="a4Btn" class="selected" onclick="setPaperSize('A4')">A4</button>
    <button id="lBtn" onclick="setPaperSize('L')">L判</button>
    <button id="posterBtn" onclick="setPaperSize('poster')">ポストカード</button>
  </div>
  
  <div class="button-group">
    <label>印刷モード:</label>
    <button id="drawOnlyBtn" class="selected" onclick="setPrintMode('drawOnly')">描画モード</button>
    <button id="fullModeBtn" onclick="setPrintMode('fullMode')">フルモード</button>
  </div>
  
  <hr style="margin: 15px 0;">
  
  <div class="button-group">
    <label>SwitchBot:</label>
    <input type="checkbox" id="switchBotEffect">
    <label for="switchBotEffect">🤖 バブル</label>
  </div>
  
  <div class="button-group">
    <button onclick="testSwitchBot()" style="background-color: #FF6B35; color: white;">🤖 Botテスト</button>
  </div>
  
  <div class="button-group">
    <label>座標テスト:</label>
    <button onclick="testDrawRightBottom()" style="background-color: #FF1493; color: white;">テスト右下</button>
  </div>
</div>

<div id="countdown"></div>

<!-- バージョン情報表示 (左下固定) -->
<div id="versionInfo" style="
  position: fixed;
  bottom: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-family: monospace;
  z-index: 9999;
  pointer-events: none;
">
  <div>Canvas Drawing Fix v2.1.0</div>
  <div id="writerStatus">Writer ID: 未割り当て</div>
</div>

<script>
// ===========================
// 🏗️ DOM CACHE SYSTEM - DOM要素キャッシュシステム
// ===========================

class DOMCache {
  constructor() {
    this.cache = new Map();
    this.contextCache = new Map();
  }
  
  // 要素を取得（キャッシュ利用）
  getElementById(id) {
    if (!this.cache.has(id)) {
      const element = document.getElementById(id);
      if (element) {
        this.cache.set(id, element);
      }
    }
    return this.cache.get(id);
  }
  
  // Canvas contextを取得（キャッシュ利用）
  getContext(canvasId, contextType = '2d') {
    const key = `${canvasId}_${contextType}`;
    if (!this.contextCache.has(key)) {
      const canvas = this.getElementById(canvasId);
      if (canvas && canvas.getContext) {
        const context = canvas.getContext(contextType);
        this.contextCache.set(key, context);
      }
    }
    return this.contextCache.get(key);
  }
  
  // 要素のキャッシュをクリア
  clearCache(id) {
    this.cache.delete(id);
    // Context関連もクリア
    for (const key of this.contextCache.keys()) {
      if (key.startsWith(id + '_')) {
        this.contextCache.delete(key);
      }
    }
  }
  
  // 全キャッシュをクリア
  clearAll() {
    this.cache.clear();
    this.contextCache.clear();
    console.log('🏗️ DOMキャッシュをクリア');
  }
  
  // バッチ取得（複数要素を一度に取得）
  getElements(ids) {
    const result = {};
    for (const id of ids) {
      result[id] = this.getElementById(id);
    }
    return result;
  }
}

// DOMCacheインスタンス作成
const domCache = new DOMCache();

// よく使う要素を事前キャッシュ
const canvas = domCache.getElementById("drawCanvas");
const ctx = domCache.getContext("drawCanvas", "2d");
let drawing = false;
let socket = new WebSocket("wss://realtime-sign-server-1.onrender.com");
// [WriterManagerに移行済み] myWriterId
let otherWritersData = {}; // 他の執筆者のデータ

// 描画状態管理用グローバル変数
let isPaintDrawing = false;
let lastPaintPos = null;

// 背景画像の範囲を計算する関数（グローバル）
let mySessionId = null; // セッション固有ID
let backgroundImage = null;
let currentPaperSize = "A4"; // 現在の用紙サイズ
let currentPrintMode = "drawOnly"; // 現在の印刷モード（デフォルト：描画モード）
let currentVideoSize = 100; // 現在のビデオサイズ（デフォルト100%）
let canvasScale = 1.4; // キャンバススケール
// ===========================
// 📋 UNIFIED SETTINGS OBJECT - 設定値統一管理
// ===========================
const APP_SETTINGS = {
  // アニメーション設定
  animationStartWaitTime: 0.1,  // アニメーション開始待機時間（秒）
  rotationWaitTime: 1.0,         // 回転後待機時間（秒）
  currentVideoPattern: 2,        // 背景5動画パターン（1:回転, 2:フェード）
  
  // 印刷設定
  printDelayTime: 5.0,          // 印刷遅延時間（秒）
  
  // 描画設定
  currentPenThickness: 6,       // 現在のペンの太さ（細い）
  currentPenColor: 'black',     // 現在のペンの色
  
  // 状態管理
  hasSentData: false            // 送信済みフラグ
};

// 後方互換性のための参照（段階的に削除予定）
let animationStartWaitTime = APP_SETTINGS.animationStartWaitTime;
let rotationWaitTime = APP_SETTINGS.rotationWaitTime;
let currentVideoPattern = APP_SETTINGS.currentVideoPattern;
let printDelayTime = APP_SETTINGS.printDelayTime;
let currentPenThickness = APP_SETTINGS.currentPenThickness;
let currentPenColor = APP_SETTINGS.currentPenColor;
let hasSentData = APP_SETTINGS.hasSentData;

// ==========================================
// カウントダウン共通システム（新機能 - 既存機能には影響なし）
// ==========================================

// カウントダウン関連定数
const COUNTDOWN_CONSTANTS = {
  CURTAIN_SECONDS: 3, // 「幕が上るまで」カウントダウン秒数
  SYNC_SECONDS: 5, // 同期カウントダウン秒数  
  UNIFIED_WAIT_TIME: 3000, // 統一待機時間（ミリ秒）
  NETWORK_DELAY: 100, // ネットワーク遅延（ミリ秒）
  SAFETY_MARGIN: 200, // 安全マージン（ミリ秒）
  MAX_RECEIVER_CURTAIN_REMAINING: 3000, // 受信側「幕が上るまで」最大残り時間（ミリ秒）
  TIMEOUT_DURATION: 5000 // タイムアウト時間（ミリ秒）
};

// ===========================
// 📊 COUNTDOWN SYSTEM - 統一化実装
// ===========================
// 
// システム構成:
// 1. COUNTDOWN_CONSTANTS: 統一された設定値
// 2. getCountdownElements(): DOM要素アクセス統一化
// 3. createCountdownNew(): 汎用カウントダウン実装
// 4. calculateCountdownTime(): 時間計算ロジック
// 5. 各種状態管理関数: hasStartedCurtainCountdown等
// 6. 実装関数群: startReceiverCurtainCountdown, startReceiverSyncCountdown等
// 
// リファクタリング完了項目:
// ✅ 定数統一化 (COUNTDOWN_CONSTANTS)
// ✅ DOM要素取得統一化 (getCountdownElements) 
// ✅ 汎用カウントダウン関数統一化 (createCountdownNew)
// ✅ 古い実装の削除とクリーンアップ
// ===========================

// DOM要素取得の共通関数群（DOMCache利用）
function getCountdownElements() {
  return {
    // 「幕が上るまで」カウントダウン関連
    curtainCountdown: domCache.getElementById('curtainCountdown'),
    curtainTimer: domCache.getElementById('curtainTimer'),
    
    // 同期カウントダウン関連
    syncCountdown: domCache.getElementById('syncCountdown'),
    
    // タイマー関連
    countdownTimer: domCache.getElementById('countdownTimer'),
    countdownText: domCache.getElementById('countdownText'),
    
    // 表示制御関連
    curtainClosedDisplay: domCache.getElementById('curtainClosedDisplay')
  };
}

// 汎用カウントダウン関数（新機能 - テスト用）
function createCountdownNew(options) {
  const {
    element,           // 表示要素
    seconds,          // カウントダウン秒数
    onTick,          // 毎秒コールバック (count) => {}
    onComplete,      // 完了時コールバック () => {}
    logPrefix = '⏱️', // ログプレフィックス
    showElement = true, // 要素を表示するか
    hideOnComplete = true // 完了時に要素を非表示にするか
  } = options;

  if (!element) {
    console.log(`❌ [新] カウントダウン要素が見つかりません`);
    return null;
  }

  let count = Math.round(seconds);
  console.log(`${logPrefix} [新] カウントダウン開始: ${count}秒`);

  // 要素を表示
  if (showElement) {
    element.style.display = 'block';
  }
  
  // 初期表示
  element.textContent = count;
  
  // カウントダウン実行
  const interval = setInterval(() => {
    count--;
    if (count > 0) {
      element.textContent = count;
      console.log(`${logPrefix} [新] カウントダウン: ${count}`);
      
      // 毎秒コールバック実行
      if (onTick) {
        onTick(count);
      }
    } else {
      // カウントダウン終了
      clearInterval(interval);
      console.log(`${logPrefix} [新] カウントダウン終了`);
      
      // 要素を非表示
      if (hideOnComplete) {
        element.style.display = 'none';
      }
      
      // 完了コールバック実行
      if (onComplete) {
        onComplete();
      }
    }
  }, 1000);

  return interval; // タイマーIDを返す
}
// ===========================
// 👤 WRITER MANAGER - WriterID管理システム
// ===========================

class WriterManager {
  constructor() {
    this.myWriterId = null;                    // 自分のWriterID
    this.drawingStates = {};                   // WriterID別の描画状態
    this.activeWriters = new Set();            // アクティブなWriter一覧
  }
  
  // 自分のWriterIDを設定
  setMyWriterId(id) {
    this.myWriterId = id;
    console.log(`👤 WriterID設定: ${id}`);
  }
  
  // 自分のWriterIDを取得
  getMyWriterId() {
    return this.myWriterId;
  }
  
  // 自分のメッセージかどうか判定
  isMyMessage(writerId) {
    return writerId === this.myWriterId;
  }
  
  // 描画状態を取得
  getDrawingState(writerId) {
    if (!this.drawingStates[writerId]) {
      this.drawingStates[writerId] = {
        isDrawing: false,
        lastX: null,
        lastY: null,
        lastTimestamp: null
      };
    }
    return this.drawingStates[writerId];
  }
  
  // 描画状態を更新
  updateDrawingState(writerId, state) {
    this.drawingStates[writerId] = {
      ...this.getDrawingState(writerId),
      ...state
    };
  }
  
  // 描画状態をリセット
  resetDrawingState(writerId) {
    delete this.drawingStates[writerId];
  }
  
  // アクティブなWriterを追加
  addActiveWriter(writerId) {
    this.activeWriters.add(writerId);
  }
  
  // アクティブなWriterを削除
  removeActiveWriter(writerId) {
    this.activeWriters.delete(writerId);
    this.resetDrawingState(writerId);
  }
  
  // すべてのWriterをクリア
  clearAll() {
    this.myWriterId = null;
    this.drawingStates = {};
    this.activeWriters.clear();
    console.log('👤 WriterManager: すべてクリア');
  }
}

// WriterManagerインスタンス作成
const writerManager = new WriterManager();

// 後方互換性のための参照（段階的に削除予定）
let myWriterId = null;
const writerDrawingStates = writerManager.drawingStates;

// 描画データを保存する配列
let drawingCommands = [];

// 現在の書き手用のレガシー変数（後方互換性のため保持）
let lastPosition = null; // 前回の位置を記録
let currentPath = []; // 現在のストロークのポイント配列
// [削除] smoothingFactor - 未使用変数を削除

// ベジェ曲線補間用の点履歴
let pointHistory = []; // 最新3点を保持してベジェ曲線を描画
const MAX_POINT_HISTORY = 3; // 保持する点の最大数
let starEffectEnabled = false; // 星エフェクトの有効/無効（標準でOFF）
let fairyDustEffectEnabled = false; // 妖精の粉エフェクトの有効/無効（標準でOFF）
let heartEffectEnabled = false; // ハートエフェクトの有効/無効（標準でOFF）- 描画時のハートは非表示
let penSoundEnabled = false; // ペン音の有効/無効（標準でOFF）
let specialBackgroundState = 'ready'; // 'ready', 'door_shown', 'door_opened'
let specialBackgroundToggle = false; // 特殊背景の画像を切り替えるフラグ

// 🎬 送信側動画背景関連変数
let senderVideoElement = null;
let isSenderVideoActive = false;

// 🎵 ペン音制御
let drawingAudio = null; // 描画中の音楽オブジェクト
let isDrawingActive = false; // 描画中フラグ
let drawingInactiveTimer = null; // 描画停止タイマー
const DRAWING_PAUSE_DELAY = 500; // 描画停止から一時停止までの遅延（ミリ秒）

// 🔍 背景デバッグ表示制御
let backgroundDebugEnabled = false;
let lastBackgroundSrc = null;

// 背景別キャンバスサイズ設定（1.02倍サイズ = 0.6*1.7）
const backgroundSizes = {
  'back3': { width: 859, height: 607 },    // 背景1 - 統一アスペクト比 (859/607 ≈ 1.415)
  'back2': { width: 859, height: 607 },    // 背景2 - 統一アスペクト比に変更
  'back4': { width: 859, height: 607 },    // 背景3 - 統一アスペクト比
  'back5': { width: 859, height: 607 },    // 背景5 - 統一アスペクト比
  'back6': { width: 859, height: 607 },    // 背景4 - 統一アスペクト比
  'white': { width: 859, height: 607 }     // 白背景 - 統一アスペクト比
};

// 🚀 非侵入的パフォーマンス最適化レイヤー
// 既存機能を一切変更せず、追加のみで最適化
let performanceOptimizer = {
  lastMouseTime: 0,
  lastTouchTime: 0,
  pendingEffects: [],
  effectAnimationId: null,
  MOUSE_THROTTLE_INTERVAL: 16, // PC用: 60fps相当
  TOUCH_THROTTLE_INTERVAL: 8,  // Redmi Pad 2軽量化: 360Hz→120Hz相当（125fps）
  
  // マウスイベントのスロットリングチェック（PC用）
  shouldProcessMouseEvent() {
    const now = Date.now();
    if (now - this.lastMouseTime < this.MOUSE_THROTTLE_INTERVAL) {
      return false;
    }
    this.lastMouseTime = now;
    return true;
  },
  
  // タッチイベントのスロットリングチェック（Redmi Pad 2最適化）
  shouldProcessTouchEvent() {
    const now = Date.now();
    if (now - this.lastTouchTime < this.TOUCH_THROTTLE_INTERVAL) {
      return false;
    }
    this.lastTouchTime = now;
    return true;
  },
  
  // エフェクト処理の遺延実行
  scheduleEffect(effectFunction) {
    this.pendingEffects.push(effectFunction);
    if (!this.effectAnimationId) {
      this.effectAnimationId = requestAnimationFrame(() => {
        // エフェクトをバッチ処理
        for (const effect of this.pendingEffects) {
          if (Math.random() < 0.3) { // 30%の確率で実行（パフォーマンス調整）
            effect();
          }
        }
        this.pendingEffects = [];
        this.effectAnimationId = null;
      });
    }
  }
};

socket.onopen = () => {
  console.log("✅ WebSocket接続完了（送信側）");
  
  // 少し待ってからwriter ID を要求（受信側の準備完了を待つ）
  setTimeout(() => {
    console.log("🔄 WriterID要求を開始");
    requestWriterId();
    
    // 初期背景画像の設定はWriterID割り当て完了後に実行するため、ここでは削除
    console.log('⏳ WriterID割り当て待ち - 背景画像送信はWriterID取得後に実行');
    
    // 初期Dev設定を受信側に送信
    setTimeout(() => {
      console.log('📤 初期Dev設定を受信側に送信');
      sendDevSettings();
    }, 1000); // WriterID取得後に送信
  }, 500);
};

socket.onmessage = (event) => {
  try {
    let data;
    
    // Blobの場合は文字列として読み取る
    if (event.data instanceof Blob) {
      const reader = new FileReader();
      reader.onload = function() {
        try {
          data = JSON.parse(reader.result);
          processMessage(data);
        } catch (error) {
          console.error('❌ Blobデータの解析エラー:', error);
        }
      };
      reader.readAsText(event.data);
      return;
    } else {
      // 文字列の場合
      data = JSON.parse(event.data);
      processMessage(data);
    }
  } catch (error) {
    console.error('❌ メッセージ処理エラー:', error);
  }
};

// ===========================
// 📡 WEBSOCKET MESSAGE HANDLERS - メッセージハンドラーマップ
// ===========================

const MESSAGE_HANDLERS = {
  // 「幕が上るまで」カウントダウンハンドラー
  'curtain-countdown': function(data) {
    console.log('📡 「幕が上るまで」カウントダウン指示を受信:', data);
    
    const curtainSeconds = data.countdown || 3;
    const isMyMessage = writerManager.isMyMessage(data.writerId);
    const hasStarted = hasStartedCurtainCountdown();
    
    console.log(`🔍 詳細判定: writerId=${data.writerId}, myWriterId=${writerManager.getMyWriterId()}, isMyMessage=${isMyMessage}, hasStarted=${hasStarted}`);
    
    if (isMyMessage && hasStarted) {
      console.log('📡 スタートを押した送信側: 既にcanvas-background.jsで「幕が上るまで」表示済み');
    } else if (isMyMessage && !hasStarted) {
      console.log('📡 スタートを押していない送信側: canvas-background.jsでのみ表示（重複回避）');
    } else {
      console.log('📡 受信側: 「幕が上るまで」カウントダウン開始');
      startReceiverCurtainCountdown(curtainSeconds);
    }
  },
  
  // 5秒カウントダウンハンドラー
  'five-second-countdown': function(data) {
    console.log('📡 5秒カウントダウン指示を受信:', data);
    
    const fiveSeconds = data.countdown || 5;
    const isStartButtonPresser = writerManager.isMyMessage(data.writerId) && hasStartedCurtainCountdown();
    
    if (isStartButtonPresser) {
      console.log('📡 スタートを押した送信側: 自分のメッセージは無視（計算ベースで既に開始済み）');
    } else {
      console.log('📡 受信側・スタートを押していない送信側: 統一された3秒待機後に5秒カウントダウン開始');
      const unifiedWaitTime = 3000;
      
      setTimeout(() => {
        console.log('📡 統一待機終了: 5秒カウントダウン開始');
        startReceiverSyncCountdown(fiveSeconds);
      }, unifiedWaitTime);
    }
  },
  
  // グローバルカウントダウンハンドラー
  'global-countdown-start': function(data) {
    console.log('📡 全体カウントダウン開始指示を受信:', data);
    
    if (writerManager.isMyMessage(data.writerId)) {
      console.log('📡 自分が送信したメッセージのため無視');
      return;
    }
    
    console.log('📡 「幕が上るまで」カウントダウンを優先するため、global-countdown-startを無視');
    
    const curtainClosedElement = domCache.getElementById('curtainClosedDisplay');
    if (curtainClosedElement) {
      curtainClosedElement.style.display = 'none';
      console.log('📡 「幕が閉じています」を非表示にしました');
    }
  }
};

// WebSocketメッセージ処理関数（リファクタ済み）
function processMessage(data) {
  console.log('🔍 processMessage呼び出し:', data.type, data);
  
  // drawタイプのメッセージをハンドラーマップで処理
  if (data.type === 'draw' && data.action) {
    const handler = MESSAGE_HANDLERS[data.action];
    if (handler) {
      handler(data);
      return;
    }
  }
  
  // 通常のdrawメッセージやその他のメッセージはwebsocket.jsに転送
  if (typeof handleWebSocketMessage === 'function') {
    handleWebSocketMessage(data);
  } else {
    console.log('🔍 handleWebSocketMessage関数が見つかりません');
  }
  
  // 従来の形式も処理（後方互換性）
  if (data.type === 'global-countdown-start') {
    // ハンドラーマップを使用
    MESSAGE_HANDLERS['global-countdown-start'](data);
    
    // 追加処理: タイミング付きカウントダウン
    const countdownTime = data.totalTime;
    const delay = data.delay || 0;
    
    if (countdownTime) {
      setTimeout(() => {
        console.log(`📡 従来形式で同期カウントダウン開始（${countdownTime}秒）`);
        startReceiverSyncCountdown(countdownTime);
      }, delay);
      console.log(`📡 ${delay}ms後にカウントダウン開始予定`);
    }
  }
}

// 不要なコントロール表示機能を削除 - シンプルなUIに統一

// デバイス検出と機能切り替えシステム
const DeviceManager = {
  // デバイスタイプを検出
  detectDevice() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    const touchSupport = 'ontouchstart' in window;
    const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;
    const maxTouchPoints = navigator.maxTouchPoints || 0;
    
    // タブレット判定
    const isTablet = (
      touchSupport &&
      maxTouchPoints > 1 &&
      (screenWidth >= 768 || screenHeight >= 768) &&
      (screenWidth <= 1024 || screenHeight <= 1024)
    ) || (
      /iPad|Android(?!.*Mobile)|Tablet/i.test(userAgent)
    );
    
    // スマートフォン判定
    const isMobile = (
      touchSupport &&
      !isTablet &&
      /Android|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)
    );
    
    // PC判定（デフォルト）
    const isPC = !isTablet && !isMobile;
    
    return {
      isPC,
      isTablet,
      isMobile,
      touchSupport,
      screenWidth,
      screenHeight,
      maxTouchPoints,
      userAgent: userAgent.substring(0, 100) // ログ用に短縮
    };
  },
  
  // デバイス別設定を適用
  applyDeviceSettings() {
    const device = this.detectDevice();
    console.log('🔍 デバイス検出結果:', device);
    
    if (device.isPC) {
      this.applyPCSettings();
    } else if (device.isTablet) {
      this.applyTabletSettings();
    } else if (device.isMobile) {
      this.applyMobileSettings();
    }
    
    return device;
  },
  
  // PC用設定
  applyPCSettings() {
    console.log('💻 PC設定を適用');
    
    // PC用の特別な設定
    const canvas = domCache.getElementById('drawCanvas');
    if (canvas) {
      // PCではマウス操作を最適化
      canvas.style.cursor = 'crosshair';
    }
    
    // PC用UIの調整
    document.body.classList.add('device-pc');
    document.body.classList.remove('device-tablet', 'device-mobile');
    
    // PC専用機能を有効化
    this.enablePCFeatures();
  },
  
  // タブレット用設定
  applyTabletSettings() {
    console.log('📱 タブレット設定を適用');
    
    // タブレット用の特別な設定
    const canvas = domCache.getElementById('drawCanvas');
    if (canvas) {
      // タブレットではタッチ操作を最適化
      canvas.style.cursor = 'none'; // カーソル非表示
    }
    
    // タブレット用UIの調整
    document.body.classList.add('device-tablet');
    document.body.classList.remove('device-pc', 'device-mobile');
    
    // タブレット専用機能を有効化
    this.enableTabletFeatures();
  },
  
  // モバイル用設定
  applyMobileSettings() {
    console.log('📱 モバイル設定を適用');
    
    // モバイル用の特別な設定
    const canvas = domCache.getElementById('drawCanvas');
    if (canvas) {
      canvas.style.cursor = 'none';
    }
    
    // モバイル用UIの調整
    document.body.classList.add('device-mobile');
    document.body.classList.remove('device-pc', 'device-tablet');
    
    // モバイル専用機能を有効化
    this.enableMobileFeatures();
  },
  
  // PC専用機能
  enablePCFeatures() {
    // PC用の詳細なDevToolsを表示
    const devButton = document.getElementById('devButton');
    if (devButton) {
      devButton.style.display = 'block';
    }
    
    // PC用のキーボードショートカットを有効化
    this.enableKeyboardShortcuts();
  },
  
  // タブレット専用機能
  enableTabletFeatures() {
    // タブレット用の大きなボタン
    const buttons = document.querySelectorAll('button');
    buttons.forEach(btn => {
      if (!btn.classList.contains('color-btn') && !btn.classList.contains('thickness-btn')) {
        btn.style.minHeight = '50px';
        btn.style.fontSize = '16px';
      }
    });
    
    // タブレット用のタッチ最適化
    this.optimizeForTouch();
  },
  
  // モバイル専用機能
  enableMobileFeatures() {
    // モバイル用の超大きなボタン
    const buttons = document.querySelectorAll('button');
    buttons.forEach(btn => {
      if (!btn.classList.contains('color-btn') && !btn.classList.contains('thickness-btn')) {
        btn.style.minHeight = '60px';
        btn.style.fontSize = '18px';
      }
    });
    
    // DevToolsを非表示（画面が小さいため）
    const devButton = document.getElementById('devButton');
    if (devButton) {
      devButton.style.display = 'none';
    }
  },
  
  // キーボードショートカット（PC専用）
  enableKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 'z':
            e.preventDefault();
            // Undo機能（将来実装）
            console.log('⌨️ Undo shortcut (PC only)');
            break;
          case 's':
            e.preventDefault();
            // Save機能
            console.log('⌨️ Save shortcut (PC only)');
            break;
        }
      }
    });
  },
  
  // タッチ最適化（タブレット/モバイル専用）
  optimizeForTouch() {
    // タッチ遅延を削除
    const style = document.createElement('style');
    style.textContent = `
      .device-tablet button, .device-mobile button {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        touch-action: manipulation;
      }
      
      .device-tablet .pen-controls, .device-mobile .pen-controls {
        gap: 15px;
      }
    `;
    document.head.appendChild(style);
  }
};
socket.onerror = (error) => console.error("❌ WebSocketエラー（送信側）:", error);
socket.onclose = (event) => {
  console.log("⚠️ WebSocket切断（送信側）:", event.code, event.reason);
  console.log("🧹 切断前の状態:", { myWriterId: writerManager.getMyWriterId(), mySessionId });
  
  // 接続切断時にセッション情報をリセット
  mySessionId = null;
  writerManager.setMyWriterId(null);  // WriterIDをクリア
  myWriterId = null;  // 後方互換性
  console.log("🧹 WebSocket切断に伴いセッション情報をリセット");
  
  // Writer ID表示をクリア
  const statusDiv = document.getElementById('writerStatus');
  if (statusDiv) {
    statusDiv.childNodes[0].textContent = 'Writer ID: 未割り当て';
  }
  document.title = '送信側 - 未接続';
};

// ハートエフェクト生成は special-effects.js で管理

// カウントダウン・設定・エフェクト関数は外部ファイルで管理

// 描画エンジンの初期化は event-handlers.js で管理
// 描画データ・保存・印刷機能は外部ファイルで管理

// 背景画像の変形パラメータ
let backgroundScale = 1.0; // スケール（大きさ）
let backgroundOffsetY = 0; // 垂直オフセット

// ===========================
// 📊 COUNTDOWN CALCULATION & UTILITIES
// ===========================

// 📊 カウントダウンタイマー機能
let countdownInterval = null;

// グローバル変数：現在のカウントダウン時間（他の関数からアクセス可能）
let currentCountdownTime = 0;

// カウントダウン時間を計算する共通関数
function calculateCountdownTime() {
  let totalTime;
  let calculation;
  
  console.log(`📊 [時間計算] 現在の設定値:`);
  console.log(`  - animationStartWaitTime: ${APP_SETTINGS.animationStartWaitTime}秒`);
  console.log(`  - rotationWaitTime: ${APP_SETTINGS.rotationWaitTime}秒`);
  console.log(`  - window.isDevWhiteBackground: ${window.isDevWhiteBackground}`);

  if (window.isDevWhiteBackground) {
    // 背景5の場合: アニメーション開始待機時間 + 動画長 + 受信側の短縮済み回転後待機時間
    // signVideo.mp4の動画長を使用 + 受信側では rotationWaitTime - 3.0秒 が適用される
    const videoDuration = 18.6; // signVideo.mp4の実際の長さ
    const receiverRotationWaitTime = Math.max(0, APP_SETTINGS.rotationWaitTime - 3.0); // 受信側では3秒短縮される（最小0秒）
    
    console.log(`📊 [背景5] 詳細計算:`);
    console.log(`  - videoDuration: ${videoDuration}秒`);
    console.log(`  - rotationWaitTime - 3.0 = ${APP_SETTINGS.rotationWaitTime} - 3.0 = ${APP_SETTINGS.rotationWaitTime - 3.0}秒`);
    console.log(`  - Math.max(0, ${APP_SETTINGS.rotationWaitTime - 3.0}) = ${receiverRotationWaitTime}秒`);
    console.log(`  - 計算式: ${APP_SETTINGS.animationStartWaitTime} + ${videoDuration} + ${receiverRotationWaitTime}`);
    
    totalTime = APP_SETTINGS.animationStartWaitTime + videoDuration + receiverRotationWaitTime;
    calculation = `開始待機:${APP_SETTINGS.animationStartWaitTime}s + 動画長:${videoDuration}s + 受信側回転後待機:${receiverRotationWaitTime}s`;
  } else {
    // 通常背景の場合: アニメーション開始待機時間 + 回転アニメーション時間(1.5s) + 受信側の短縮済み回転後待機時間
    const receiverRotationWaitTime = Math.max(0, APP_SETTINGS.rotationWaitTime - 3.0); // 受信側では3秒短縮される（最小0秒）
    
    console.log(`📊 [通常背景] 詳細計算:`);
    console.log(`  - rotationWaitTime - 3.0 = ${APP_SETTINGS.rotationWaitTime} - 3.0 = ${APP_SETTINGS.rotationWaitTime - 3.0}秒`);
    console.log(`  - Math.max(0, ${APP_SETTINGS.rotationWaitTime - 3.0}) = ${receiverRotationWaitTime}秒`);
    console.log(`  - 計算式: ${APP_SETTINGS.animationStartWaitTime} + 1.5 + ${receiverRotationWaitTime}`);
    
    totalTime = APP_SETTINGS.animationStartWaitTime + 1.5 + receiverRotationWaitTime;
    calculation = `開始待機:${APP_SETTINGS.animationStartWaitTime}s + 回転:1.5s + 受信側回転後待機:${receiverRotationWaitTime}s`;
  }
  
  console.log(`📊 [計算結果] totalTime = ${totalTime}秒 (${calculation})`);
  return totalTime;
}

// [削除済み] startCountdownTimer - 使用されていない古い実装

// [削除済み] startReceiverCountdownTimer と startSyncedCountdownTimer - 使用されていない古い実装

// [削除済み] stopCountdownTimer - 使用されていない古い実装

// ===========================
// 📊 COUNTDOWN STATE MANAGEMENT
// ===========================

// スタートボタンを押したかどうかを判定
function hasStartedCurtainCountdown() {
  // canvas-background.jsの関数が存在し、実際にスタートボタンが押されているかチェック
  // startWaitingAnimation関数が呼ばれたかどうかで判定
  const result = typeof startWaitingAnimation !== 'undefined' && window.hasStartedAnimation === true;
  console.log(`🔍 hasStartedCurtainCountdown: startWaitingAnimation=${typeof startWaitingAnimation}, hasStartedAnimation=${window.hasStartedAnimation}, result=${result}`);
  return result;
}

// 受信側の「幕が上るまで」カウントダウン終了までの遅延を計算（canvas-background.jsと同じロジック）
function calculateReceiverCurtainDelay() {
  // WebSocket通信遅延: 約100ms
  const networkDelay = 100;
  
  // 受信側の「幕が上るまで」は最大3秒残っている可能性
  const maxReceiverCurtainRemaining = 3000; // 3秒
  
  // 安全マージン
  const safetyMargin = 200; // 0.2秒
  
  const totalDelay = networkDelay + maxReceiverCurtainRemaining + safetyMargin;
  
  console.log(`📊 remotesign.html遅延計算: 通信${networkDelay}ms + 最大幕残り${maxReceiverCurtainRemaining}ms + マージン${safetyMargin}ms = ${totalDelay}ms`);
  
  return totalDelay;
}

// 「幕が上るまで」カウントダウン終了を待ってから5秒カウントダウンを開始
function waitForCurtainEndThenStartCountdown(fiveSeconds) {
  const curtainCountdown = document.getElementById('curtainCountdown');
  
  // 「幕が上るまで」カウントダウンの終了を監視
  const checkInterval = setInterval(() => {
    if (!curtainCountdown || curtainCountdown.style.display === 'none') {
      // 「幕が上るまで」カウントダウンが終了した
      clearInterval(checkInterval);
      console.log('📡 受信側: 「幕が上るまで」終了を検知、5秒カウントダウン開始');
      startReceiverSyncCountdown(fiveSeconds);
    }
  }, 100); // 100ms間隔でチェック
  
  // 安全のため、最大5秒でタイムアウト
  setTimeout(() => {
    clearInterval(checkInterval);
    console.log('📡 受信側: タイムアウトで5秒カウントダウンを強制開始');
    startReceiverSyncCountdown(fiveSeconds);
  }, 5000);
}

// ===========================
// 📊 COUNTDOWN IMPLEMENTATIONS
// ===========================

// [削除済み] startReceiverCurtainCountdown_OLD - 古いバックアップ実装（新実装で置換済み）

// 受信側用の「幕が上るまで」カウントダウン関数（統一実装使用）
function startReceiverCurtainCountdown(seconds) {
  console.log(`🎭 受信側「幕が上るまで」カウントダウン開始: ${seconds}秒`);
  
  const elements = getCountdownElements();
  
  if (!elements.curtainCountdown || !elements.curtainTimer) {
    console.log('❌ 受信側: curtainCountdown要素が見つかりません');
    return;
  }
  
  // curtainCountdown全体を表示
  elements.curtainCountdown.style.display = 'block';
  
  // 新しいカウントダウンシステムを使用
  return createCountdownNew({
    element: elements.curtainTimer,
    seconds: seconds,
    logPrefix: '🎭 受信側',
    showElement: false, // curtainCountdownを手動で表示制御
    hideOnComplete: false, // 手動で非表示制御
    onComplete: () => {
      elements.curtainCountdown.style.display = 'none';
      console.log('🎭 受信側: 幕が上りました！');
    }
  });
}

// 受信側用の同期カウントダウン関数（新実装使用）
function startReceiverSyncCountdown(totalTime) {
  console.log(`⏱️ [新実装] 受信側同期カウントダウン開始: ${totalTime}秒`);
  
  const elements = getCountdownElements();
  const curtainClosedElement = domCache.getElementById('curtainClosedDisplay');
  
  if (!elements.syncCountdown) {
    console.log('❌ 受信側: syncCountdown要素が見つかりません');
    return;
  }
  
  // 幕が閉じています表示を非表示
  if (curtainClosedElement) {
    curtainClosedElement.style.display = 'none';
  }
  
  // 新しい統一カウントダウンを使用
  createCountdownNew({
    element: elements.syncCountdown,
    seconds: totalTime,
    onTick: (remaining) => {
      console.log(`⏱️ 受信側カウントダウン: ${remaining}`);
    },
    onComplete: () => {
      console.log('⏱️ 受信側カウントダウン終了');
      // カウントダウン終了後に幕が閉じています表示を再表示
      if (curtainClosedElement) {
        curtainClosedElement.style.display = 'block';
      }
    },
    logPrefix: '⏱️ [受信側同期]',
    showElement: true,
    hideOnComplete: true
  });
}

// 🎯 イベントハンドラー・初期化処理 (キーボードイベント, DOMContentLoaded, タッチイベント) はevent-handlers.jsに移動しました
</script>
</div>

<!-- 重複したコントロールパネルを削除 -->

</div>

<!-- 視覚エフェクト機能を外部ファイルから読み込み -->
<script src="effects.js"></script>

<!-- 特殊エフェクト機能（ハート・花火・紙吹雪）を外部ファイルから読み込み -->
<script src="special-effects.js"></script>

<!-- 設定・ユーティリティ機能を外部ファイルから読み込み -->
<script src="settings.js"></script>

<!-- WebSocket・通信機能を外部ファイルから読み込み -->
<script src="websocket.js"></script>

<!-- 背景・キャンバス管理機能を外部ファイルから読み込み -->
<script src="canvas-background.js"></script>
<!-- 送信側動画機能を外部ファイルから読み込み -->
<script src="video-sender.js"></script>
<!-- 音楽・音声機能を外部ファイルから読み込み -->
<script src="audio-music.js"></script>
<!-- ユーティリティ・計算機能を外部ファイルから読み込み -->
<script src="utils.js"></script>
<!-- 描画ライン機能を外部ファイルから読み込み -->
<script src="drawing-lines.js"></script>
<!-- 描画エンジン機能を外部ファイルから読み込み -->
<script src="drawing-engine.js"></script>
<!-- 印刷・保存機能を外部ファイルから読み込み -->
<script src="print-save.js"></script>
<!-- 開発ツール機能を外部ファイルから読み込み -->
<script src="dev-tools.js"></script>
<!-- UI制御・テーマ機能を外部ファイルから読み込み -->
<script src="ui-controls.js"></script>
<!-- イベントハンドラー・初期化機能を外部ファイルから読み込み -->
<script src="event-handlers.js"></script>

</body>
</html>
